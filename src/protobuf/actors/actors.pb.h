// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: actors.proto

#ifndef PROTOBUF_actors_2eproto__INCLUDED
#define PROTOBUF_actors_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace amarlon {
namespace proto {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_actors_2eproto();
void protobuf_AssignDesc_actors_2eproto();
void protobuf_ShutdownFile_actors_2eproto();

class ActorData;
class ActorData_Ai;
class ActorData_Character;
class ActorData_Character_AbilityScores;
class ActorData_Character_Spell;
class ActorData_Destroyable;
class ActorData_Destroyable_DropRule;
class ActorData_Inventory;
class ActorData_Openable;
class ActorData_Pickable;
class ActorData_Wearer;
class ActorData_Wearer_ItemSlot;
class ActorsData;

// ===================================================================

class ActorData_Inventory : public ::google::protobuf::Message {
 public:
  ActorData_Inventory();
  virtual ~ActorData_Inventory();

  ActorData_Inventory(const ActorData_Inventory& from);

  inline ActorData_Inventory& operator=(const ActorData_Inventory& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Inventory& default_instance();

  void Swap(ActorData_Inventory* other);

  // implements Message ----------------------------------------------

  inline ActorData_Inventory* New() const { return New(NULL); }

  ActorData_Inventory* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Inventory& from);
  void MergeFrom(const ActorData_Inventory& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Inventory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 slots = 1 [default = 20];
  bool has_slots() const;
  void clear_slots();
  static const int kSlotsFieldNumber = 1;
  ::google::protobuf::int32 slots() const;
  void set_slots(::google::protobuf::int32 value);

  // repeated .amarlon.proto.ActorData item = 2;
  int item_size() const;
  void clear_item();
  static const int kItemFieldNumber = 2;
  const ::amarlon::proto::ActorData& item(int index) const;
  ::amarlon::proto::ActorData* mutable_item(int index);
  ::amarlon::proto::ActorData* add_item();
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >*
      mutable_item();
  const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >&
      item() const;

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Inventory)
 private:
  inline void set_has_slots();
  inline void clear_has_slots();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData > item_;
  ::google::protobuf::int32 slots_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Inventory* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Character_AbilityScores : public ::google::protobuf::Message {
 public:
  ActorData_Character_AbilityScores();
  virtual ~ActorData_Character_AbilityScores();

  ActorData_Character_AbilityScores(const ActorData_Character_AbilityScores& from);

  inline ActorData_Character_AbilityScores& operator=(const ActorData_Character_AbilityScores& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Character_AbilityScores& default_instance();

  void Swap(ActorData_Character_AbilityScores* other);

  // implements Message ----------------------------------------------

  inline ActorData_Character_AbilityScores* New() const { return New(NULL); }

  ActorData_Character_AbilityScores* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Character_AbilityScores& from);
  void MergeFrom(const ActorData_Character_AbilityScores& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Character_AbilityScores* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 STR = 1;
  bool has_str() const;
  void clear_str();
  static const int kSTRFieldNumber = 1;
  ::google::protobuf::int32 str() const;
  void set_str(::google::protobuf::int32 value);

  // required int32 INT = 2;
  bool has_int_() const;
  void clear_int_();
  static const int kINTFieldNumber = 2;
  ::google::protobuf::int32 int_() const;
  void set_int_(::google::protobuf::int32 value);

  // required int32 WIS = 3;
  bool has_wis() const;
  void clear_wis();
  static const int kWISFieldNumber = 3;
  ::google::protobuf::int32 wis() const;
  void set_wis(::google::protobuf::int32 value);

  // required int32 DEX = 4;
  bool has_dex() const;
  void clear_dex();
  static const int kDEXFieldNumber = 4;
  ::google::protobuf::int32 dex() const;
  void set_dex(::google::protobuf::int32 value);

  // required int32 CON = 5;
  bool has_con() const;
  void clear_con();
  static const int kCONFieldNumber = 5;
  ::google::protobuf::int32 con() const;
  void set_con(::google::protobuf::int32 value);

  // required int32 CHA = 6;
  bool has_cha() const;
  void clear_cha();
  static const int kCHAFieldNumber = 6;
  ::google::protobuf::int32 cha() const;
  void set_cha(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Character.AbilityScores)
 private:
  inline void set_has_str();
  inline void clear_has_str();
  inline void set_has_int_();
  inline void clear_has_int_();
  inline void set_has_wis();
  inline void clear_has_wis();
  inline void set_has_dex();
  inline void clear_has_dex();
  inline void set_has_con();
  inline void clear_has_con();
  inline void set_has_cha();
  inline void clear_has_cha();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 str_;
  ::google::protobuf::int32 int__;
  ::google::protobuf::int32 wis_;
  ::google::protobuf::int32 dex_;
  ::google::protobuf::int32 con_;
  ::google::protobuf::int32 cha_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Character_AbilityScores* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Character_Spell : public ::google::protobuf::Message {
 public:
  ActorData_Character_Spell();
  virtual ~ActorData_Character_Spell();

  ActorData_Character_Spell(const ActorData_Character_Spell& from);

  inline ActorData_Character_Spell& operator=(const ActorData_Character_Spell& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Character_Spell& default_instance();

  void Swap(ActorData_Character_Spell* other);

  // implements Message ----------------------------------------------

  inline ActorData_Character_Spell* New() const { return New(NULL); }

  ActorData_Character_Spell* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Character_Spell& from);
  void MergeFrom(const ActorData_Character_Spell& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Character_Spell* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Character.Spell)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Character_Spell* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Character : public ::google::protobuf::Message {
 public:
  ActorData_Character();
  virtual ~ActorData_Character();

  ActorData_Character(const ActorData_Character& from);

  inline ActorData_Character& operator=(const ActorData_Character& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Character& default_instance();

  void Swap(ActorData_Character* other);

  // implements Message ----------------------------------------------

  inline ActorData_Character* New() const { return New(NULL); }

  ActorData_Character* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Character& from);
  void MergeFrom(const ActorData_Character& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Character* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActorData_Character_AbilityScores AbilityScores;
  typedef ActorData_Character_Spell Spell;

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  bool has_level() const;
  void clear_level();
  static const int kLevelFieldNumber = 1;
  ::google::protobuf::int32 level() const;
  void set_level(::google::protobuf::int32 value);

  // required int32 class = 2;
  bool has_class_() const;
  void clear_class_();
  static const int kClassFieldNumber = 2;
  ::google::protobuf::int32 class_() const;
  void set_class_(::google::protobuf::int32 value);

  // required int32 race = 3;
  bool has_race() const;
  void clear_race();
  static const int kRaceFieldNumber = 3;
  ::google::protobuf::int32 race() const;
  void set_race(::google::protobuf::int32 value);

  // optional int32 experience = 4 [default = 0];
  bool has_experience() const;
  void clear_experience();
  static const int kExperienceFieldNumber = 4;
  ::google::protobuf::int32 experience() const;
  void set_experience(::google::protobuf::int32 value);

  // optional int32 armor = 5 [default = 0];
  bool has_armor() const;
  void clear_armor();
  static const int kArmorFieldNumber = 5;
  ::google::protobuf::int32 armor() const;
  void set_armor(::google::protobuf::int32 value);

  // optional int32 speed = 6 [default = 40];
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // optional int32 hp = 7 [default = 0];
  bool has_hp() const;
  void clear_hp();
  static const int kHpFieldNumber = 7;
  ::google::protobuf::int32 hp() const;
  void set_hp(::google::protobuf::int32 value);

  // optional int32 maxHp = 8 [default = 0];
  bool has_maxhp() const;
  void clear_maxhp();
  static const int kMaxHpFieldNumber = 8;
  ::google::protobuf::int32 maxhp() const;
  void set_maxhp(::google::protobuf::int32 value);

  // optional int32 hpBonus = 9 [default = 0];
  bool has_hpbonus() const;
  void clear_hpbonus();
  static const int kHpBonusFieldNumber = 9;
  ::google::protobuf::int32 hpbonus() const;
  void set_hpbonus(::google::protobuf::int32 value);

  // optional string damage = 10 [default = "0d0+0#0"];
  bool has_damage() const;
  void clear_damage();
  static const int kDamageFieldNumber = 10;
  const ::std::string& damage() const;
  void set_damage(const ::std::string& value);
  void set_damage(const char* value);
  void set_damage(const char* value, size_t size);
  ::std::string* mutable_damage();
  ::std::string* release_damage();
  void set_allocated_damage(::std::string* damage);

  // optional int32 morale = 11 [default = 0];
  bool has_morale() const;
  void clear_morale();
  static const int kMoraleFieldNumber = 11;
  ::google::protobuf::int32 morale() const;
  void set_morale(::google::protobuf::int32 value);

  // optional .amarlon.proto.ActorData.Character.AbilityScores abilityScores = 12;
  bool has_abilityscores() const;
  void clear_abilityscores();
  static const int kAbilityScoresFieldNumber = 12;
  const ::amarlon::proto::ActorData_Character_AbilityScores& abilityscores() const;
  ::amarlon::proto::ActorData_Character_AbilityScores* mutable_abilityscores();
  ::amarlon::proto::ActorData_Character_AbilityScores* release_abilityscores();
  void set_allocated_abilityscores(::amarlon::proto::ActorData_Character_AbilityScores* abilityscores);

  // repeated .amarlon.proto.ActorData.Character.Spell spells = 13;
  int spells_size() const;
  void clear_spells();
  static const int kSpellsFieldNumber = 13;
  const ::amarlon::proto::ActorData_Character_Spell& spells(int index) const;
  ::amarlon::proto::ActorData_Character_Spell* mutable_spells(int index);
  ::amarlon::proto::ActorData_Character_Spell* add_spells();
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Character_Spell >*
      mutable_spells();
  const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Character_Spell >&
      spells() const;

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Character)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_class_();
  inline void clear_has_class_();
  inline void set_has_race();
  inline void clear_has_race();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_hpbonus();
  inline void clear_has_hpbonus();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_morale();
  inline void clear_has_morale();
  inline void set_has_abilityscores();
  inline void clear_has_abilityscores();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 class__;
  ::google::protobuf::int32 race_;
  ::google::protobuf::int32 experience_;
  ::google::protobuf::int32 armor_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 maxhp_;
  static ::std::string* _default_damage_;
  ::google::protobuf::internal::ArenaStringPtr damage_;
  ::google::protobuf::int32 hpbonus_;
  ::google::protobuf::int32 morale_;
  ::amarlon::proto::ActorData_Character_AbilityScores* abilityscores_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Character_Spell > spells_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Character* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Destroyable_DropRule : public ::google::protobuf::Message {
 public:
  ActorData_Destroyable_DropRule();
  virtual ~ActorData_Destroyable_DropRule();

  ActorData_Destroyable_DropRule(const ActorData_Destroyable_DropRule& from);

  inline ActorData_Destroyable_DropRule& operator=(const ActorData_Destroyable_DropRule& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Destroyable_DropRule& default_instance();

  void Swap(ActorData_Destroyable_DropRule* other);

  // implements Message ----------------------------------------------

  inline ActorData_Destroyable_DropRule* New() const { return New(NULL); }

  ActorData_Destroyable_DropRule* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Destroyable_DropRule& from);
  void MergeFrom(const ActorData_Destroyable_DropRule& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Destroyable_DropRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemId = 1;
  bool has_itemid() const;
  void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  ::google::protobuf::int32 itemid() const;
  void set_itemid(::google::protobuf::int32 value);

  // optional int32 min = 2 [default = 1];
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 2;
  ::google::protobuf::int32 min() const;
  void set_min(::google::protobuf::int32 value);

  // optional int32 max = 3 [default = 1];
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 3;
  ::google::protobuf::int32 max() const;
  void set_max(::google::protobuf::int32 value);

  // optional float chance = 4 [default = 1];
  bool has_chance() const;
  void clear_chance();
  static const int kChanceFieldNumber = 4;
  float chance() const;
  void set_chance(float value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Destroyable.DropRule)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_min();
  inline void clear_has_min();
  inline void set_has_max();
  inline void clear_has_max();
  inline void set_has_chance();
  inline void clear_has_chance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 min_;
  ::google::protobuf::int32 max_;
  float chance_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Destroyable_DropRule* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Destroyable : public ::google::protobuf::Message {
 public:
  ActorData_Destroyable();
  virtual ~ActorData_Destroyable();

  ActorData_Destroyable(const ActorData_Destroyable& from);

  inline ActorData_Destroyable& operator=(const ActorData_Destroyable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Destroyable& default_instance();

  void Swap(ActorData_Destroyable* other);

  // implements Message ----------------------------------------------

  inline ActorData_Destroyable* New() const { return New(NULL); }

  ActorData_Destroyable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Destroyable& from);
  void MergeFrom(const ActorData_Destroyable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Destroyable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActorData_Destroyable_DropRule DropRule;

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Destroyable)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Destroyable* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Wearer_ItemSlot : public ::google::protobuf::Message {
 public:
  ActorData_Wearer_ItemSlot();
  virtual ~ActorData_Wearer_ItemSlot();

  ActorData_Wearer_ItemSlot(const ActorData_Wearer_ItemSlot& from);

  inline ActorData_Wearer_ItemSlot& operator=(const ActorData_Wearer_ItemSlot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Wearer_ItemSlot& default_instance();

  void Swap(ActorData_Wearer_ItemSlot* other);

  // implements Message ----------------------------------------------

  inline ActorData_Wearer_ItemSlot* New() const { return New(NULL); }

  ActorData_Wearer_ItemSlot* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Wearer_ItemSlot& from);
  void MergeFrom(const ActorData_Wearer_ItemSlot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Wearer_ItemSlot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional .amarlon.proto.ActorData item = 2;
  bool has_item() const;
  void clear_item();
  static const int kItemFieldNumber = 2;
  const ::amarlon::proto::ActorData& item() const;
  ::amarlon::proto::ActorData* mutable_item();
  ::amarlon::proto::ActorData* release_item();
  void set_allocated_item(::amarlon::proto::ActorData* item);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Wearer.ItemSlot)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::amarlon::proto::ActorData* item_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Wearer_ItemSlot* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Wearer : public ::google::protobuf::Message {
 public:
  ActorData_Wearer();
  virtual ~ActorData_Wearer();

  ActorData_Wearer(const ActorData_Wearer& from);

  inline ActorData_Wearer& operator=(const ActorData_Wearer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Wearer& default_instance();

  void Swap(ActorData_Wearer* other);

  // implements Message ----------------------------------------------

  inline ActorData_Wearer* New() const { return New(NULL); }

  ActorData_Wearer* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Wearer& from);
  void MergeFrom(const ActorData_Wearer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Wearer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActorData_Wearer_ItemSlot ItemSlot;

  // accessors -------------------------------------------------------

  // repeated .amarlon.proto.ActorData.Wearer.ItemSlot itemSlots = 1;
  int itemslots_size() const;
  void clear_itemslots();
  static const int kItemSlotsFieldNumber = 1;
  const ::amarlon::proto::ActorData_Wearer_ItemSlot& itemslots(int index) const;
  ::amarlon::proto::ActorData_Wearer_ItemSlot* mutable_itemslots(int index);
  ::amarlon::proto::ActorData_Wearer_ItemSlot* add_itemslots();
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Wearer_ItemSlot >*
      mutable_itemslots();
  const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Wearer_ItemSlot >&
      itemslots() const;

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Wearer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Wearer_ItemSlot > itemslots_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Wearer* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Ai : public ::google::protobuf::Message {
 public:
  ActorData_Ai();
  virtual ~ActorData_Ai();

  ActorData_Ai(const ActorData_Ai& from);

  inline ActorData_Ai& operator=(const ActorData_Ai& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Ai& default_instance();

  void Swap(ActorData_Ai* other);

  // implements Message ----------------------------------------------

  inline ActorData_Ai* New() const { return New(NULL); }

  ActorData_Ai* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Ai& from);
  void MergeFrom(const ActorData_Ai& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Ai* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Ai)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Ai* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Openable : public ::google::protobuf::Message {
 public:
  ActorData_Openable();
  virtual ~ActorData_Openable();

  ActorData_Openable(const ActorData_Openable& from);

  inline ActorData_Openable& operator=(const ActorData_Openable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Openable& default_instance();

  void Swap(ActorData_Openable* other);

  // implements Message ----------------------------------------------

  inline ActorData_Openable* New() const { return New(NULL); }

  ActorData_Openable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Openable& from);
  void MergeFrom(const ActorData_Openable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Openable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 scriptId = 1;
  bool has_scriptid() const;
  void clear_scriptid();
  static const int kScriptIdFieldNumber = 1;
  ::google::protobuf::int32 scriptid() const;
  void set_scriptid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Openable)
 private:
  inline void set_has_scriptid();
  inline void clear_has_scriptid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 scriptid_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Openable* default_instance_;
};
// -------------------------------------------------------------------

class ActorData_Pickable : public ::google::protobuf::Message {
 public:
  ActorData_Pickable();
  virtual ~ActorData_Pickable();

  ActorData_Pickable(const ActorData_Pickable& from);

  inline ActorData_Pickable& operator=(const ActorData_Pickable& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData_Pickable& default_instance();

  void Swap(ActorData_Pickable* other);

  // implements Message ----------------------------------------------

  inline ActorData_Pickable* New() const { return New(NULL); }

  ActorData_Pickable* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData_Pickable& from);
  void MergeFrom(const ActorData_Pickable& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData_Pickable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool stackable = 1 [default = false];
  bool has_stackable() const;
  void clear_stackable();
  static const int kStackableFieldNumber = 1;
  bool stackable() const;
  void set_stackable(bool value);

  // optional int32 amount = 2 [default = 1];
  bool has_amount() const;
  void clear_amount();
  static const int kAmountFieldNumber = 2;
  ::google::protobuf::int32 amount() const;
  void set_amount(::google::protobuf::int32 value);

  // optional int32 uses = 3 [default = 0];
  bool has_uses() const;
  void clear_uses();
  static const int kUsesFieldNumber = 3;
  ::google::protobuf::int32 uses() const;
  void set_uses(::google::protobuf::int32 value);

  // optional int32 itemSlot = 4 [default = 0];
  bool has_itemslot() const;
  void clear_itemslot();
  static const int kItemSlotFieldNumber = 4;
  ::google::protobuf::int32 itemslot() const;
  void set_itemslot(::google::protobuf::int32 value);

  // optional int32 category = 5 [default = 0];
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 5;
  ::google::protobuf::int32 category() const;
  void set_category(::google::protobuf::int32 value);

  // optional int32 armor = 6 [default = 0];
  bool has_armor() const;
  void clear_armor();
  static const int kArmorFieldNumber = 6;
  ::google::protobuf::int32 armor() const;
  void set_armor(::google::protobuf::int32 value);

  // optional int32 weight = 7 [default = 0];
  bool has_weight() const;
  void clear_weight();
  static const int kWeightFieldNumber = 7;
  ::google::protobuf::int32 weight() const;
  void set_weight(::google::protobuf::int32 value);

  // optional int32 price = 8 [default = 0];
  bool has_price() const;
  void clear_price();
  static const int kPriceFieldNumber = 8;
  ::google::protobuf::int32 price() const;
  void set_price(::google::protobuf::int32 value);

  // optional int32 target = 9 [default = 0];
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 9;
  ::google::protobuf::int32 target() const;
  void set_target(::google::protobuf::int32 value);

  // optional string damage = 10 [default = "0d0+0#0"];
  bool has_damage() const;
  void clear_damage();
  static const int kDamageFieldNumber = 10;
  const ::std::string& damage() const;
  void set_damage(const ::std::string& value);
  void set_damage(const char* value);
  void set_damage(const char* value, size_t size);
  ::std::string* mutable_damage();
  ::std::string* release_damage();
  void set_allocated_damage(::std::string* damage);

  // optional int32 scriptId = 11 [default = 0];
  bool has_scriptid() const;
  void clear_scriptid();
  static const int kScriptIdFieldNumber = 11;
  ::google::protobuf::int32 scriptid() const;
  void set_scriptid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData.Pickable)
 private:
  inline void set_has_stackable();
  inline void clear_has_stackable();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_uses();
  inline void clear_has_uses();
  inline void set_has_itemslot();
  inline void clear_has_itemslot();
  inline void set_has_category();
  inline void clear_has_category();
  inline void set_has_armor();
  inline void clear_has_armor();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_scriptid();
  inline void clear_has_scriptid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool stackable_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::int32 uses_;
  ::google::protobuf::int32 itemslot_;
  ::google::protobuf::int32 category_;
  ::google::protobuf::int32 armor_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 price_;
  static ::std::string* _default_damage_;
  ::google::protobuf::internal::ArenaStringPtr damage_;
  ::google::protobuf::int32 target_;
  ::google::protobuf::int32 scriptid_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData_Pickable* default_instance_;
};
// -------------------------------------------------------------------

class ActorData : public ::google::protobuf::Message {
 public:
  ActorData();
  virtual ~ActorData();

  ActorData(const ActorData& from);

  inline ActorData& operator=(const ActorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData& default_instance();

  void Swap(ActorData* other);

  // implements Message ----------------------------------------------

  inline ActorData* New() const { return New(NULL); }

  ActorData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData& from);
  void MergeFrom(const ActorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ActorData_Inventory Inventory;
  typedef ActorData_Character Character;
  typedef ActorData_Destroyable Destroyable;
  typedef ActorData_Wearer Wearer;
  typedef ActorData_Ai Ai;
  typedef ActorData_Openable Openable;
  typedef ActorData_Pickable Pickable;

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string symbol = 3 [default = "@"];
  bool has_symbol() const;
  void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  const ::std::string& symbol() const;
  void set_symbol(const ::std::string& value);
  void set_symbol(const char* value);
  void set_symbol(const char* value, size_t size);
  ::std::string* mutable_symbol();
  ::std::string* release_symbol();
  void set_allocated_symbol(::std::string* symbol);

  // optional string color = 4 [default = "ffffff"];
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 4;
  const ::std::string& color() const;
  void set_color(const ::std::string& value);
  void set_color(const char* value);
  void set_color(const char* value, size_t size);
  ::std::string* mutable_color();
  ::std::string* release_color();
  void set_allocated_color(::std::string* color);

  // optional bool blocks = 5 [default = true];
  bool has_blocks() const;
  void clear_blocks();
  static const int kBlocksFieldNumber = 5;
  bool blocks() const;
  void set_blocks(bool value);

  // optional bool fovOnly = 6 [default = true];
  bool has_fovonly() const;
  void clear_fovonly();
  static const int kFovOnlyFieldNumber = 6;
  bool fovonly() const;
  void set_fovonly(bool value);

  // optional string description = 7 [default = ""];
  bool has_description() const;
  void clear_description();
  static const int kDescriptionFieldNumber = 7;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // optional .amarlon.proto.ActorData.Inventory inventory = 8;
  bool has_inventory() const;
  void clear_inventory();
  static const int kInventoryFieldNumber = 8;
  const ::amarlon::proto::ActorData_Inventory& inventory() const;
  ::amarlon::proto::ActorData_Inventory* mutable_inventory();
  ::amarlon::proto::ActorData_Inventory* release_inventory();
  void set_allocated_inventory(::amarlon::proto::ActorData_Inventory* inventory);

  // optional .amarlon.proto.ActorData.Character character = 9;
  bool has_character() const;
  void clear_character();
  static const int kCharacterFieldNumber = 9;
  const ::amarlon::proto::ActorData_Character& character() const;
  ::amarlon::proto::ActorData_Character* mutable_character();
  ::amarlon::proto::ActorData_Character* release_character();
  void set_allocated_character(::amarlon::proto::ActorData_Character* character);

  // optional .amarlon.proto.ActorData.Destroyable destroyable = 10;
  bool has_destroyable() const;
  void clear_destroyable();
  static const int kDestroyableFieldNumber = 10;
  const ::amarlon::proto::ActorData_Destroyable& destroyable() const;
  ::amarlon::proto::ActorData_Destroyable* mutable_destroyable();
  ::amarlon::proto::ActorData_Destroyable* release_destroyable();
  void set_allocated_destroyable(::amarlon::proto::ActorData_Destroyable* destroyable);

  // optional .amarlon.proto.ActorData.Wearer wearer = 11;
  bool has_wearer() const;
  void clear_wearer();
  static const int kWearerFieldNumber = 11;
  const ::amarlon::proto::ActorData_Wearer& wearer() const;
  ::amarlon::proto::ActorData_Wearer* mutable_wearer();
  ::amarlon::proto::ActorData_Wearer* release_wearer();
  void set_allocated_wearer(::amarlon::proto::ActorData_Wearer* wearer);

  // optional .amarlon.proto.ActorData.Ai ai = 12;
  bool has_ai() const;
  void clear_ai();
  static const int kAiFieldNumber = 12;
  const ::amarlon::proto::ActorData_Ai& ai() const;
  ::amarlon::proto::ActorData_Ai* mutable_ai();
  ::amarlon::proto::ActorData_Ai* release_ai();
  void set_allocated_ai(::amarlon::proto::ActorData_Ai* ai);

  // optional .amarlon.proto.ActorData.Openable openable = 13;
  bool has_openable() const;
  void clear_openable();
  static const int kOpenableFieldNumber = 13;
  const ::amarlon::proto::ActorData_Openable& openable() const;
  ::amarlon::proto::ActorData_Openable* mutable_openable();
  ::amarlon::proto::ActorData_Openable* release_openable();
  void set_allocated_openable(::amarlon::proto::ActorData_Openable* openable);

  // optional .amarlon.proto.ActorData.Pickable pickable = 14;
  bool has_pickable() const;
  void clear_pickable();
  static const int kPickableFieldNumber = 14;
  const ::amarlon::proto::ActorData_Pickable& pickable() const;
  ::amarlon::proto::ActorData_Pickable* mutable_pickable();
  ::amarlon::proto::ActorData_Pickable* release_pickable();
  void set_allocated_pickable(::amarlon::proto::ActorData_Pickable* pickable);

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_fovonly();
  inline void clear_has_fovonly();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_character();
  inline void clear_has_character();
  inline void set_has_destroyable();
  inline void clear_has_destroyable();
  inline void set_has_wearer();
  inline void clear_has_wearer();
  inline void set_has_ai();
  inline void clear_has_ai();
  inline void set_has_openable();
  inline void clear_has_openable();
  inline void set_has_pickable();
  inline void clear_has_pickable();

  // helper for ByteSize()
  int RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  static ::std::string* _default_symbol_;
  ::google::protobuf::internal::ArenaStringPtr symbol_;
  static ::std::string* _default_color_;
  ::google::protobuf::internal::ArenaStringPtr color_;
  ::google::protobuf::int32 id_;
  bool blocks_;
  bool fovonly_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::amarlon::proto::ActorData_Inventory* inventory_;
  ::amarlon::proto::ActorData_Character* character_;
  ::amarlon::proto::ActorData_Destroyable* destroyable_;
  ::amarlon::proto::ActorData_Wearer* wearer_;
  ::amarlon::proto::ActorData_Ai* ai_;
  ::amarlon::proto::ActorData_Openable* openable_;
  ::amarlon::proto::ActorData_Pickable* pickable_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorData* default_instance_;
};
// -------------------------------------------------------------------

class ActorsData : public ::google::protobuf::Message {
 public:
  ActorsData();
  virtual ~ActorsData();

  ActorsData(const ActorsData& from);

  inline ActorsData& operator=(const ActorsData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorsData& default_instance();

  void Swap(ActorsData* other);

  // implements Message ----------------------------------------------

  inline ActorsData* New() const { return New(NULL); }

  ActorsData* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorsData& from);
  void MergeFrom(const ActorsData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ActorsData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .amarlon.proto.ActorData actor = 1;
  int actor_size() const;
  void clear_actor();
  static const int kActorFieldNumber = 1;
  const ::amarlon::proto::ActorData& actor(int index) const;
  ::amarlon::proto::ActorData* mutable_actor(int index);
  ::amarlon::proto::ActorData* add_actor();
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >*
      mutable_actor();
  const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >&
      actor() const;

  // @@protoc_insertion_point(class_scope:amarlon.proto.ActorsData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData > actor_;
  friend void  protobuf_AddDesc_actors_2eproto();
  friend void protobuf_AssignDesc_actors_2eproto();
  friend void protobuf_ShutdownFile_actors_2eproto();

  void InitAsDefaultInstance();
  static ActorsData* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// ActorData_Inventory

// optional int32 slots = 1 [default = 20];
inline bool ActorData_Inventory::has_slots() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Inventory::set_has_slots() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Inventory::clear_has_slots() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Inventory::clear_slots() {
  slots_ = 20;
  clear_has_slots();
}
inline ::google::protobuf::int32 ActorData_Inventory::slots() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Inventory.slots)
  return slots_;
}
inline void ActorData_Inventory::set_slots(::google::protobuf::int32 value) {
  set_has_slots();
  slots_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Inventory.slots)
}

// repeated .amarlon.proto.ActorData item = 2;
inline int ActorData_Inventory::item_size() const {
  return item_.size();
}
inline void ActorData_Inventory::clear_item() {
  item_.Clear();
}
inline const ::amarlon::proto::ActorData& ActorData_Inventory::item(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Inventory.item)
  return item_.Get(index);
}
inline ::amarlon::proto::ActorData* ActorData_Inventory::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Inventory.item)
  return item_.Mutable(index);
}
inline ::amarlon::proto::ActorData* ActorData_Inventory::add_item() {
  // @@protoc_insertion_point(field_add:amarlon.proto.ActorData.Inventory.item)
  return item_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >*
ActorData_Inventory::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.proto.ActorData.Inventory.item)
  return &item_;
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >&
ActorData_Inventory::item() const {
  // @@protoc_insertion_point(field_list:amarlon.proto.ActorData.Inventory.item)
  return item_;
}

// -------------------------------------------------------------------

// ActorData_Character_AbilityScores

// required int32 STR = 1;
inline bool ActorData_Character_AbilityScores::has_str() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_str() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Character_AbilityScores::clear_has_str() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Character_AbilityScores::clear_str() {
  str_ = 0;
  clear_has_str();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::str() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.STR)
  return str_;
}
inline void ActorData_Character_AbilityScores::set_str(::google::protobuf::int32 value) {
  set_has_str();
  str_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.STR)
}

// required int32 INT = 2;
inline bool ActorData_Character_AbilityScores::has_int_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_int_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData_Character_AbilityScores::clear_has_int_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData_Character_AbilityScores::clear_int_() {
  int__ = 0;
  clear_has_int_();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::int_() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.INT)
  return int__;
}
inline void ActorData_Character_AbilityScores::set_int_(::google::protobuf::int32 value) {
  set_has_int_();
  int__ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.INT)
}

// required int32 WIS = 3;
inline bool ActorData_Character_AbilityScores::has_wis() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_wis() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData_Character_AbilityScores::clear_has_wis() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData_Character_AbilityScores::clear_wis() {
  wis_ = 0;
  clear_has_wis();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::wis() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.WIS)
  return wis_;
}
inline void ActorData_Character_AbilityScores::set_wis(::google::protobuf::int32 value) {
  set_has_wis();
  wis_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.WIS)
}

// required int32 DEX = 4;
inline bool ActorData_Character_AbilityScores::has_dex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_dex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData_Character_AbilityScores::clear_has_dex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData_Character_AbilityScores::clear_dex() {
  dex_ = 0;
  clear_has_dex();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::dex() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.DEX)
  return dex_;
}
inline void ActorData_Character_AbilityScores::set_dex(::google::protobuf::int32 value) {
  set_has_dex();
  dex_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.DEX)
}

// required int32 CON = 5;
inline bool ActorData_Character_AbilityScores::has_con() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_con() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorData_Character_AbilityScores::clear_has_con() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorData_Character_AbilityScores::clear_con() {
  con_ = 0;
  clear_has_con();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::con() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.CON)
  return con_;
}
inline void ActorData_Character_AbilityScores::set_con(::google::protobuf::int32 value) {
  set_has_con();
  con_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.CON)
}

// required int32 CHA = 6;
inline bool ActorData_Character_AbilityScores::has_cha() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActorData_Character_AbilityScores::set_has_cha() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActorData_Character_AbilityScores::clear_has_cha() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActorData_Character_AbilityScores::clear_cha() {
  cha_ = 0;
  clear_has_cha();
}
inline ::google::protobuf::int32 ActorData_Character_AbilityScores::cha() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.AbilityScores.CHA)
  return cha_;
}
inline void ActorData_Character_AbilityScores::set_cha(::google::protobuf::int32 value) {
  set_has_cha();
  cha_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.AbilityScores.CHA)
}

// -------------------------------------------------------------------

// ActorData_Character_Spell

// required int32 id = 1;
inline bool ActorData_Character_Spell::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Character_Spell::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Character_Spell::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Character_Spell::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActorData_Character_Spell::id() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.Spell.id)
  return id_;
}
inline void ActorData_Character_Spell::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.Spell.id)
}

// -------------------------------------------------------------------

// ActorData_Character

// required int32 level = 1;
inline bool ActorData_Character::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Character::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Character::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Character::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 ActorData_Character::level() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.level)
  return level_;
}
inline void ActorData_Character::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.level)
}

// required int32 class = 2;
inline bool ActorData_Character::has_class_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData_Character::set_has_class_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData_Character::clear_has_class_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData_Character::clear_class_() {
  class__ = 0;
  clear_has_class_();
}
inline ::google::protobuf::int32 ActorData_Character::class_() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.class)
  return class__;
}
inline void ActorData_Character::set_class_(::google::protobuf::int32 value) {
  set_has_class_();
  class__ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.class)
}

// required int32 race = 3;
inline bool ActorData_Character::has_race() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData_Character::set_has_race() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData_Character::clear_has_race() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData_Character::clear_race() {
  race_ = 0;
  clear_has_race();
}
inline ::google::protobuf::int32 ActorData_Character::race() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.race)
  return race_;
}
inline void ActorData_Character::set_race(::google::protobuf::int32 value) {
  set_has_race();
  race_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.race)
}

// optional int32 experience = 4 [default = 0];
inline bool ActorData_Character::has_experience() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData_Character::set_has_experience() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData_Character::clear_has_experience() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData_Character::clear_experience() {
  experience_ = 0;
  clear_has_experience();
}
inline ::google::protobuf::int32 ActorData_Character::experience() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.experience)
  return experience_;
}
inline void ActorData_Character::set_experience(::google::protobuf::int32 value) {
  set_has_experience();
  experience_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.experience)
}

// optional int32 armor = 5 [default = 0];
inline bool ActorData_Character::has_armor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorData_Character::set_has_armor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorData_Character::clear_has_armor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorData_Character::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline ::google::protobuf::int32 ActorData_Character::armor() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.armor)
  return armor_;
}
inline void ActorData_Character::set_armor(::google::protobuf::int32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.armor)
}

// optional int32 speed = 6 [default = 40];
inline bool ActorData_Character::has_speed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActorData_Character::set_has_speed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActorData_Character::clear_has_speed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActorData_Character::clear_speed() {
  speed_ = 40;
  clear_has_speed();
}
inline ::google::protobuf::int32 ActorData_Character::speed() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.speed)
  return speed_;
}
inline void ActorData_Character::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.speed)
}

// optional int32 hp = 7 [default = 0];
inline bool ActorData_Character::has_hp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActorData_Character::set_has_hp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActorData_Character::clear_has_hp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActorData_Character::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 ActorData_Character::hp() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.hp)
  return hp_;
}
inline void ActorData_Character::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.hp)
}

// optional int32 maxHp = 8 [default = 0];
inline bool ActorData_Character::has_maxhp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActorData_Character::set_has_maxhp() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActorData_Character::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActorData_Character::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 ActorData_Character::maxhp() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.maxHp)
  return maxhp_;
}
inline void ActorData_Character::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.maxHp)
}

// optional int32 hpBonus = 9 [default = 0];
inline bool ActorData_Character::has_hpbonus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActorData_Character::set_has_hpbonus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActorData_Character::clear_has_hpbonus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActorData_Character::clear_hpbonus() {
  hpbonus_ = 0;
  clear_has_hpbonus();
}
inline ::google::protobuf::int32 ActorData_Character::hpbonus() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.hpBonus)
  return hpbonus_;
}
inline void ActorData_Character::set_hpbonus(::google::protobuf::int32 value) {
  set_has_hpbonus();
  hpbonus_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.hpBonus)
}

// optional string damage = 10 [default = "0d0+0#0"];
inline bool ActorData_Character::has_damage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActorData_Character::set_has_damage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActorData_Character::clear_has_damage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActorData_Character::clear_damage() {
  damage_.ClearToDefaultNoArena(_default_damage_);
  clear_has_damage();
}
inline const ::std::string& ActorData_Character::damage() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.damage)
  return damage_.GetNoArena(_default_damage_);
}
inline void ActorData_Character::set_damage(const ::std::string& value) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_, value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.damage)
}
inline void ActorData_Character::set_damage(const char* value) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.Character.damage)
}
inline void ActorData_Character::set_damage(const char* value, size_t size) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.Character.damage)
}
inline ::std::string* ActorData_Character::mutable_damage() {
  set_has_damage();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Character.damage)
  return damage_.MutableNoArena(_default_damage_);
}
inline ::std::string* ActorData_Character::release_damage() {
  clear_has_damage();
  return damage_.ReleaseNoArena(_default_damage_);
}
inline void ActorData_Character::set_allocated_damage(::std::string* damage) {
  if (damage != NULL) {
    set_has_damage();
  } else {
    clear_has_damage();
  }
  damage_.SetAllocatedNoArena(_default_damage_, damage);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.Character.damage)
}

// optional int32 morale = 11 [default = 0];
inline bool ActorData_Character::has_morale() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActorData_Character::set_has_morale() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActorData_Character::clear_has_morale() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActorData_Character::clear_morale() {
  morale_ = 0;
  clear_has_morale();
}
inline ::google::protobuf::int32 ActorData_Character::morale() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.morale)
  return morale_;
}
inline void ActorData_Character::set_morale(::google::protobuf::int32 value) {
  set_has_morale();
  morale_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Character.morale)
}

// optional .amarlon.proto.ActorData.Character.AbilityScores abilityScores = 12;
inline bool ActorData_Character::has_abilityscores() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ActorData_Character::set_has_abilityscores() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ActorData_Character::clear_has_abilityscores() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ActorData_Character::clear_abilityscores() {
  if (abilityscores_ != NULL) abilityscores_->::amarlon::proto::ActorData_Character_AbilityScores::Clear();
  clear_has_abilityscores();
}
inline const ::amarlon::proto::ActorData_Character_AbilityScores& ActorData_Character::abilityscores() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.abilityScores)
  return abilityscores_ != NULL ? *abilityscores_ : *default_instance_->abilityscores_;
}
inline ::amarlon::proto::ActorData_Character_AbilityScores* ActorData_Character::mutable_abilityscores() {
  set_has_abilityscores();
  if (abilityscores_ == NULL) {
    abilityscores_ = new ::amarlon::proto::ActorData_Character_AbilityScores;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Character.abilityScores)
  return abilityscores_;
}
inline ::amarlon::proto::ActorData_Character_AbilityScores* ActorData_Character::release_abilityscores() {
  clear_has_abilityscores();
  ::amarlon::proto::ActorData_Character_AbilityScores* temp = abilityscores_;
  abilityscores_ = NULL;
  return temp;
}
inline void ActorData_Character::set_allocated_abilityscores(::amarlon::proto::ActorData_Character_AbilityScores* abilityscores) {
  delete abilityscores_;
  abilityscores_ = abilityscores;
  if (abilityscores) {
    set_has_abilityscores();
  } else {
    clear_has_abilityscores();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.Character.abilityScores)
}

// repeated .amarlon.proto.ActorData.Character.Spell spells = 13;
inline int ActorData_Character::spells_size() const {
  return spells_.size();
}
inline void ActorData_Character::clear_spells() {
  spells_.Clear();
}
inline const ::amarlon::proto::ActorData_Character_Spell& ActorData_Character::spells(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Character.spells)
  return spells_.Get(index);
}
inline ::amarlon::proto::ActorData_Character_Spell* ActorData_Character::mutable_spells(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Character.spells)
  return spells_.Mutable(index);
}
inline ::amarlon::proto::ActorData_Character_Spell* ActorData_Character::add_spells() {
  // @@protoc_insertion_point(field_add:amarlon.proto.ActorData.Character.spells)
  return spells_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Character_Spell >*
ActorData_Character::mutable_spells() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.proto.ActorData.Character.spells)
  return &spells_;
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Character_Spell >&
ActorData_Character::spells() const {
  // @@protoc_insertion_point(field_list:amarlon.proto.ActorData.Character.spells)
  return spells_;
}

// -------------------------------------------------------------------

// ActorData_Destroyable_DropRule

// required int32 itemId = 1;
inline bool ActorData_Destroyable_DropRule::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Destroyable_DropRule::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Destroyable_DropRule::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Destroyable_DropRule::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ActorData_Destroyable_DropRule::itemid() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Destroyable.DropRule.itemId)
  return itemid_;
}
inline void ActorData_Destroyable_DropRule::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Destroyable.DropRule.itemId)
}

// optional int32 min = 2 [default = 1];
inline bool ActorData_Destroyable_DropRule::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData_Destroyable_DropRule::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData_Destroyable_DropRule::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData_Destroyable_DropRule::clear_min() {
  min_ = 1;
  clear_has_min();
}
inline ::google::protobuf::int32 ActorData_Destroyable_DropRule::min() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Destroyable.DropRule.min)
  return min_;
}
inline void ActorData_Destroyable_DropRule::set_min(::google::protobuf::int32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Destroyable.DropRule.min)
}

// optional int32 max = 3 [default = 1];
inline bool ActorData_Destroyable_DropRule::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData_Destroyable_DropRule::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData_Destroyable_DropRule::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData_Destroyable_DropRule::clear_max() {
  max_ = 1;
  clear_has_max();
}
inline ::google::protobuf::int32 ActorData_Destroyable_DropRule::max() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Destroyable.DropRule.max)
  return max_;
}
inline void ActorData_Destroyable_DropRule::set_max(::google::protobuf::int32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Destroyable.DropRule.max)
}

// optional float chance = 4 [default = 1];
inline bool ActorData_Destroyable_DropRule::has_chance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData_Destroyable_DropRule::set_has_chance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData_Destroyable_DropRule::clear_has_chance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData_Destroyable_DropRule::clear_chance() {
  chance_ = 1;
  clear_has_chance();
}
inline float ActorData_Destroyable_DropRule::chance() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Destroyable.DropRule.chance)
  return chance_;
}
inline void ActorData_Destroyable_DropRule::set_chance(float value) {
  set_has_chance();
  chance_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Destroyable.DropRule.chance)
}

// -------------------------------------------------------------------

// ActorData_Destroyable

// -------------------------------------------------------------------

// ActorData_Wearer_ItemSlot

// required int32 id = 1;
inline bool ActorData_Wearer_ItemSlot::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Wearer_ItemSlot::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Wearer_ItemSlot::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Wearer_ItemSlot::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActorData_Wearer_ItemSlot::id() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Wearer.ItemSlot.id)
  return id_;
}
inline void ActorData_Wearer_ItemSlot::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Wearer.ItemSlot.id)
}

// optional .amarlon.proto.ActorData item = 2;
inline bool ActorData_Wearer_ItemSlot::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData_Wearer_ItemSlot::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData_Wearer_ItemSlot::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData_Wearer_ItemSlot::clear_item() {
  if (item_ != NULL) item_->::amarlon::proto::ActorData::Clear();
  clear_has_item();
}
inline const ::amarlon::proto::ActorData& ActorData_Wearer_ItemSlot::item() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Wearer.ItemSlot.item)
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::amarlon::proto::ActorData* ActorData_Wearer_ItemSlot::mutable_item() {
  set_has_item();
  if (item_ == NULL) {
    item_ = new ::amarlon::proto::ActorData;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Wearer.ItemSlot.item)
  return item_;
}
inline ::amarlon::proto::ActorData* ActorData_Wearer_ItemSlot::release_item() {
  clear_has_item();
  ::amarlon::proto::ActorData* temp = item_;
  item_ = NULL;
  return temp;
}
inline void ActorData_Wearer_ItemSlot::set_allocated_item(::amarlon::proto::ActorData* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.Wearer.ItemSlot.item)
}

// -------------------------------------------------------------------

// ActorData_Wearer

// repeated .amarlon.proto.ActorData.Wearer.ItemSlot itemSlots = 1;
inline int ActorData_Wearer::itemslots_size() const {
  return itemslots_.size();
}
inline void ActorData_Wearer::clear_itemslots() {
  itemslots_.Clear();
}
inline const ::amarlon::proto::ActorData_Wearer_ItemSlot& ActorData_Wearer::itemslots(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Wearer.itemSlots)
  return itemslots_.Get(index);
}
inline ::amarlon::proto::ActorData_Wearer_ItemSlot* ActorData_Wearer::mutable_itemslots(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Wearer.itemSlots)
  return itemslots_.Mutable(index);
}
inline ::amarlon::proto::ActorData_Wearer_ItemSlot* ActorData_Wearer::add_itemslots() {
  // @@protoc_insertion_point(field_add:amarlon.proto.ActorData.Wearer.itemSlots)
  return itemslots_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Wearer_ItemSlot >*
ActorData_Wearer::mutable_itemslots() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.proto.ActorData.Wearer.itemSlots)
  return &itemslots_;
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData_Wearer_ItemSlot >&
ActorData_Wearer::itemslots() const {
  // @@protoc_insertion_point(field_list:amarlon.proto.ActorData.Wearer.itemSlots)
  return itemslots_;
}

// -------------------------------------------------------------------

// ActorData_Ai

// required int32 type = 1;
inline bool ActorData_Ai::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Ai::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Ai::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Ai::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ActorData_Ai::type() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Ai.type)
  return type_;
}
inline void ActorData_Ai::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Ai.type)
}

// -------------------------------------------------------------------

// ActorData_Openable

// required int32 scriptId = 1;
inline bool ActorData_Openable::has_scriptid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Openable::set_has_scriptid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Openable::clear_has_scriptid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Openable::clear_scriptid() {
  scriptid_ = 0;
  clear_has_scriptid();
}
inline ::google::protobuf::int32 ActorData_Openable::scriptid() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Openable.scriptId)
  return scriptid_;
}
inline void ActorData_Openable::set_scriptid(::google::protobuf::int32 value) {
  set_has_scriptid();
  scriptid_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Openable.scriptId)
}

// -------------------------------------------------------------------

// ActorData_Pickable

// optional bool stackable = 1 [default = false];
inline bool ActorData_Pickable::has_stackable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData_Pickable::set_has_stackable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData_Pickable::clear_has_stackable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData_Pickable::clear_stackable() {
  stackable_ = false;
  clear_has_stackable();
}
inline bool ActorData_Pickable::stackable() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.stackable)
  return stackable_;
}
inline void ActorData_Pickable::set_stackable(bool value) {
  set_has_stackable();
  stackable_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.stackable)
}

// optional int32 amount = 2 [default = 1];
inline bool ActorData_Pickable::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData_Pickable::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData_Pickable::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData_Pickable::clear_amount() {
  amount_ = 1;
  clear_has_amount();
}
inline ::google::protobuf::int32 ActorData_Pickable::amount() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.amount)
  return amount_;
}
inline void ActorData_Pickable::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.amount)
}

// optional int32 uses = 3 [default = 0];
inline bool ActorData_Pickable::has_uses() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData_Pickable::set_has_uses() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData_Pickable::clear_has_uses() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData_Pickable::clear_uses() {
  uses_ = 0;
  clear_has_uses();
}
inline ::google::protobuf::int32 ActorData_Pickable::uses() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.uses)
  return uses_;
}
inline void ActorData_Pickable::set_uses(::google::protobuf::int32 value) {
  set_has_uses();
  uses_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.uses)
}

// optional int32 itemSlot = 4 [default = 0];
inline bool ActorData_Pickable::has_itemslot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData_Pickable::set_has_itemslot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData_Pickable::clear_has_itemslot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData_Pickable::clear_itemslot() {
  itemslot_ = 0;
  clear_has_itemslot();
}
inline ::google::protobuf::int32 ActorData_Pickable::itemslot() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.itemSlot)
  return itemslot_;
}
inline void ActorData_Pickable::set_itemslot(::google::protobuf::int32 value) {
  set_has_itemslot();
  itemslot_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.itemSlot)
}

// optional int32 category = 5 [default = 0];
inline bool ActorData_Pickable::has_category() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorData_Pickable::set_has_category() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorData_Pickable::clear_has_category() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorData_Pickable::clear_category() {
  category_ = 0;
  clear_has_category();
}
inline ::google::protobuf::int32 ActorData_Pickable::category() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.category)
  return category_;
}
inline void ActorData_Pickable::set_category(::google::protobuf::int32 value) {
  set_has_category();
  category_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.category)
}

// optional int32 armor = 6 [default = 0];
inline bool ActorData_Pickable::has_armor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActorData_Pickable::set_has_armor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActorData_Pickable::clear_has_armor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActorData_Pickable::clear_armor() {
  armor_ = 0;
  clear_has_armor();
}
inline ::google::protobuf::int32 ActorData_Pickable::armor() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.armor)
  return armor_;
}
inline void ActorData_Pickable::set_armor(::google::protobuf::int32 value) {
  set_has_armor();
  armor_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.armor)
}

// optional int32 weight = 7 [default = 0];
inline bool ActorData_Pickable::has_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActorData_Pickable::set_has_weight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActorData_Pickable::clear_has_weight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActorData_Pickable::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 ActorData_Pickable::weight() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.weight)
  return weight_;
}
inline void ActorData_Pickable::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.weight)
}

// optional int32 price = 8 [default = 0];
inline bool ActorData_Pickable::has_price() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActorData_Pickable::set_has_price() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActorData_Pickable::clear_has_price() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActorData_Pickable::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 ActorData_Pickable::price() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.price)
  return price_;
}
inline void ActorData_Pickable::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.price)
}

// optional int32 target = 9 [default = 0];
inline bool ActorData_Pickable::has_target() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActorData_Pickable::set_has_target() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActorData_Pickable::clear_has_target() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActorData_Pickable::clear_target() {
  target_ = 0;
  clear_has_target();
}
inline ::google::protobuf::int32 ActorData_Pickable::target() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.target)
  return target_;
}
inline void ActorData_Pickable::set_target(::google::protobuf::int32 value) {
  set_has_target();
  target_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.target)
}

// optional string damage = 10 [default = "0d0+0#0"];
inline bool ActorData_Pickable::has_damage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActorData_Pickable::set_has_damage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActorData_Pickable::clear_has_damage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActorData_Pickable::clear_damage() {
  damage_.ClearToDefaultNoArena(_default_damage_);
  clear_has_damage();
}
inline const ::std::string& ActorData_Pickable::damage() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.damage)
  return damage_.GetNoArena(_default_damage_);
}
inline void ActorData_Pickable::set_damage(const ::std::string& value) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_, value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.damage)
}
inline void ActorData_Pickable::set_damage(const char* value) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.Pickable.damage)
}
inline void ActorData_Pickable::set_damage(const char* value, size_t size) {
  set_has_damage();
  damage_.SetNoArena(_default_damage_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.Pickable.damage)
}
inline ::std::string* ActorData_Pickable::mutable_damage() {
  set_has_damage();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.Pickable.damage)
  return damage_.MutableNoArena(_default_damage_);
}
inline ::std::string* ActorData_Pickable::release_damage() {
  clear_has_damage();
  return damage_.ReleaseNoArena(_default_damage_);
}
inline void ActorData_Pickable::set_allocated_damage(::std::string* damage) {
  if (damage != NULL) {
    set_has_damage();
  } else {
    clear_has_damage();
  }
  damage_.SetAllocatedNoArena(_default_damage_, damage);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.Pickable.damage)
}

// optional int32 scriptId = 11 [default = 0];
inline bool ActorData_Pickable::has_scriptid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActorData_Pickable::set_has_scriptid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActorData_Pickable::clear_has_scriptid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActorData_Pickable::clear_scriptid() {
  scriptid_ = 0;
  clear_has_scriptid();
}
inline ::google::protobuf::int32 ActorData_Pickable::scriptid() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.Pickable.scriptId)
  return scriptid_;
}
inline void ActorData_Pickable::set_scriptid(::google::protobuf::int32 value) {
  set_has_scriptid();
  scriptid_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.Pickable.scriptId)
}

// -------------------------------------------------------------------

// ActorData

// required int32 id = 1;
inline bool ActorData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ActorData::id() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.id)
  return id_;
}
inline void ActorData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.id)
}

// required string name = 2;
inline bool ActorData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& ActorData::name() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActorData::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.name)
}
inline void ActorData::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.name)
}
inline void ActorData::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.name)
}
inline ::std::string* ActorData::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActorData::release_name() {
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActorData::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.name)
}

// optional string symbol = 3 [default = "@"];
inline bool ActorData::has_symbol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData::set_has_symbol() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData::clear_symbol() {
  symbol_.ClearToDefaultNoArena(_default_symbol_);
  clear_has_symbol();
}
inline const ::std::string& ActorData::symbol() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.symbol)
  return symbol_.GetNoArena(_default_symbol_);
}
inline void ActorData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  symbol_.SetNoArena(_default_symbol_, value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.symbol)
}
inline void ActorData::set_symbol(const char* value) {
  set_has_symbol();
  symbol_.SetNoArena(_default_symbol_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.symbol)
}
inline void ActorData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  symbol_.SetNoArena(_default_symbol_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.symbol)
}
inline ::std::string* ActorData::mutable_symbol() {
  set_has_symbol();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.symbol)
  return symbol_.MutableNoArena(_default_symbol_);
}
inline ::std::string* ActorData::release_symbol() {
  clear_has_symbol();
  return symbol_.ReleaseNoArena(_default_symbol_);
}
inline void ActorData::set_allocated_symbol(::std::string* symbol) {
  if (symbol != NULL) {
    set_has_symbol();
  } else {
    clear_has_symbol();
  }
  symbol_.SetAllocatedNoArena(_default_symbol_, symbol);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.symbol)
}

// optional string color = 4 [default = "ffffff"];
inline bool ActorData::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData::clear_color() {
  color_.ClearToDefaultNoArena(_default_color_);
  clear_has_color();
}
inline const ::std::string& ActorData::color() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.color)
  return color_.GetNoArena(_default_color_);
}
inline void ActorData::set_color(const ::std::string& value) {
  set_has_color();
  color_.SetNoArena(_default_color_, value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.color)
}
inline void ActorData::set_color(const char* value) {
  set_has_color();
  color_.SetNoArena(_default_color_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.color)
}
inline void ActorData::set_color(const char* value, size_t size) {
  set_has_color();
  color_.SetNoArena(_default_color_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.color)
}
inline ::std::string* ActorData::mutable_color() {
  set_has_color();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.color)
  return color_.MutableNoArena(_default_color_);
}
inline ::std::string* ActorData::release_color() {
  clear_has_color();
  return color_.ReleaseNoArena(_default_color_);
}
inline void ActorData::set_allocated_color(::std::string* color) {
  if (color != NULL) {
    set_has_color();
  } else {
    clear_has_color();
  }
  color_.SetAllocatedNoArena(_default_color_, color);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.color)
}

// optional bool blocks = 5 [default = true];
inline bool ActorData::has_blocks() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorData::set_has_blocks() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorData::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorData::clear_blocks() {
  blocks_ = true;
  clear_has_blocks();
}
inline bool ActorData::blocks() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.blocks)
  return blocks_;
}
inline void ActorData::set_blocks(bool value) {
  set_has_blocks();
  blocks_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.blocks)
}

// optional bool fovOnly = 6 [default = true];
inline bool ActorData::has_fovonly() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActorData::set_has_fovonly() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActorData::clear_has_fovonly() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActorData::clear_fovonly() {
  fovonly_ = true;
  clear_has_fovonly();
}
inline bool ActorData::fovonly() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.fovOnly)
  return fovonly_;
}
inline void ActorData::set_fovonly(bool value) {
  set_has_fovonly();
  fovonly_ = value;
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.fovOnly)
}

// optional string description = 7 [default = ""];
inline bool ActorData::has_description() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActorData::set_has_description() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActorData::clear_has_description() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActorData::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_description();
}
inline const ::std::string& ActorData::description() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.description)
  return description_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActorData::set_description(const ::std::string& value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:amarlon.proto.ActorData.description)
}
inline void ActorData::set_description(const char* value) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:amarlon.proto.ActorData.description)
}
inline void ActorData::set_description(const char* value, size_t size) {
  set_has_description();
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:amarlon.proto.ActorData.description)
}
inline ::std::string* ActorData::mutable_description() {
  set_has_description();
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ActorData::release_description() {
  clear_has_description();
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ActorData::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    set_has_description();
  } else {
    clear_has_description();
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.description)
}

// optional .amarlon.proto.ActorData.Inventory inventory = 8;
inline bool ActorData::has_inventory() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActorData::set_has_inventory() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActorData::clear_has_inventory() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActorData::clear_inventory() {
  if (inventory_ != NULL) inventory_->::amarlon::proto::ActorData_Inventory::Clear();
  clear_has_inventory();
}
inline const ::amarlon::proto::ActorData_Inventory& ActorData::inventory() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.inventory)
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::amarlon::proto::ActorData_Inventory* ActorData::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) {
    inventory_ = new ::amarlon::proto::ActorData_Inventory;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.inventory)
  return inventory_;
}
inline ::amarlon::proto::ActorData_Inventory* ActorData::release_inventory() {
  clear_has_inventory();
  ::amarlon::proto::ActorData_Inventory* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_inventory(::amarlon::proto::ActorData_Inventory* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.inventory)
}

// optional .amarlon.proto.ActorData.Character character = 9;
inline bool ActorData::has_character() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActorData::set_has_character() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActorData::clear_has_character() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActorData::clear_character() {
  if (character_ != NULL) character_->::amarlon::proto::ActorData_Character::Clear();
  clear_has_character();
}
inline const ::amarlon::proto::ActorData_Character& ActorData::character() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.character)
  return character_ != NULL ? *character_ : *default_instance_->character_;
}
inline ::amarlon::proto::ActorData_Character* ActorData::mutable_character() {
  set_has_character();
  if (character_ == NULL) {
    character_ = new ::amarlon::proto::ActorData_Character;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.character)
  return character_;
}
inline ::amarlon::proto::ActorData_Character* ActorData::release_character() {
  clear_has_character();
  ::amarlon::proto::ActorData_Character* temp = character_;
  character_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_character(::amarlon::proto::ActorData_Character* character) {
  delete character_;
  character_ = character;
  if (character) {
    set_has_character();
  } else {
    clear_has_character();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.character)
}

// optional .amarlon.proto.ActorData.Destroyable destroyable = 10;
inline bool ActorData::has_destroyable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActorData::set_has_destroyable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActorData::clear_has_destroyable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActorData::clear_destroyable() {
  if (destroyable_ != NULL) destroyable_->::amarlon::proto::ActorData_Destroyable::Clear();
  clear_has_destroyable();
}
inline const ::amarlon::proto::ActorData_Destroyable& ActorData::destroyable() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.destroyable)
  return destroyable_ != NULL ? *destroyable_ : *default_instance_->destroyable_;
}
inline ::amarlon::proto::ActorData_Destroyable* ActorData::mutable_destroyable() {
  set_has_destroyable();
  if (destroyable_ == NULL) {
    destroyable_ = new ::amarlon::proto::ActorData_Destroyable;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.destroyable)
  return destroyable_;
}
inline ::amarlon::proto::ActorData_Destroyable* ActorData::release_destroyable() {
  clear_has_destroyable();
  ::amarlon::proto::ActorData_Destroyable* temp = destroyable_;
  destroyable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_destroyable(::amarlon::proto::ActorData_Destroyable* destroyable) {
  delete destroyable_;
  destroyable_ = destroyable;
  if (destroyable) {
    set_has_destroyable();
  } else {
    clear_has_destroyable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.destroyable)
}

// optional .amarlon.proto.ActorData.Wearer wearer = 11;
inline bool ActorData::has_wearer() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActorData::set_has_wearer() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActorData::clear_has_wearer() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActorData::clear_wearer() {
  if (wearer_ != NULL) wearer_->::amarlon::proto::ActorData_Wearer::Clear();
  clear_has_wearer();
}
inline const ::amarlon::proto::ActorData_Wearer& ActorData::wearer() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.wearer)
  return wearer_ != NULL ? *wearer_ : *default_instance_->wearer_;
}
inline ::amarlon::proto::ActorData_Wearer* ActorData::mutable_wearer() {
  set_has_wearer();
  if (wearer_ == NULL) {
    wearer_ = new ::amarlon::proto::ActorData_Wearer;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.wearer)
  return wearer_;
}
inline ::amarlon::proto::ActorData_Wearer* ActorData::release_wearer() {
  clear_has_wearer();
  ::amarlon::proto::ActorData_Wearer* temp = wearer_;
  wearer_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_wearer(::amarlon::proto::ActorData_Wearer* wearer) {
  delete wearer_;
  wearer_ = wearer;
  if (wearer) {
    set_has_wearer();
  } else {
    clear_has_wearer();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.wearer)
}

// optional .amarlon.proto.ActorData.Ai ai = 12;
inline bool ActorData::has_ai() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ActorData::set_has_ai() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ActorData::clear_has_ai() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ActorData::clear_ai() {
  if (ai_ != NULL) ai_->::amarlon::proto::ActorData_Ai::Clear();
  clear_has_ai();
}
inline const ::amarlon::proto::ActorData_Ai& ActorData::ai() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.ai)
  return ai_ != NULL ? *ai_ : *default_instance_->ai_;
}
inline ::amarlon::proto::ActorData_Ai* ActorData::mutable_ai() {
  set_has_ai();
  if (ai_ == NULL) {
    ai_ = new ::amarlon::proto::ActorData_Ai;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.ai)
  return ai_;
}
inline ::amarlon::proto::ActorData_Ai* ActorData::release_ai() {
  clear_has_ai();
  ::amarlon::proto::ActorData_Ai* temp = ai_;
  ai_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_ai(::amarlon::proto::ActorData_Ai* ai) {
  delete ai_;
  ai_ = ai;
  if (ai) {
    set_has_ai();
  } else {
    clear_has_ai();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.ai)
}

// optional .amarlon.proto.ActorData.Openable openable = 13;
inline bool ActorData::has_openable() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ActorData::set_has_openable() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ActorData::clear_has_openable() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ActorData::clear_openable() {
  if (openable_ != NULL) openable_->::amarlon::proto::ActorData_Openable::Clear();
  clear_has_openable();
}
inline const ::amarlon::proto::ActorData_Openable& ActorData::openable() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.openable)
  return openable_ != NULL ? *openable_ : *default_instance_->openable_;
}
inline ::amarlon::proto::ActorData_Openable* ActorData::mutable_openable() {
  set_has_openable();
  if (openable_ == NULL) {
    openable_ = new ::amarlon::proto::ActorData_Openable;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.openable)
  return openable_;
}
inline ::amarlon::proto::ActorData_Openable* ActorData::release_openable() {
  clear_has_openable();
  ::amarlon::proto::ActorData_Openable* temp = openable_;
  openable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_openable(::amarlon::proto::ActorData_Openable* openable) {
  delete openable_;
  openable_ = openable;
  if (openable) {
    set_has_openable();
  } else {
    clear_has_openable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.openable)
}

// optional .amarlon.proto.ActorData.Pickable pickable = 14;
inline bool ActorData::has_pickable() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ActorData::set_has_pickable() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ActorData::clear_has_pickable() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ActorData::clear_pickable() {
  if (pickable_ != NULL) pickable_->::amarlon::proto::ActorData_Pickable::Clear();
  clear_has_pickable();
}
inline const ::amarlon::proto::ActorData_Pickable& ActorData::pickable() const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorData.pickable)
  return pickable_ != NULL ? *pickable_ : *default_instance_->pickable_;
}
inline ::amarlon::proto::ActorData_Pickable* ActorData::mutable_pickable() {
  set_has_pickable();
  if (pickable_ == NULL) {
    pickable_ = new ::amarlon::proto::ActorData_Pickable;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorData.pickable)
  return pickable_;
}
inline ::amarlon::proto::ActorData_Pickable* ActorData::release_pickable() {
  clear_has_pickable();
  ::amarlon::proto::ActorData_Pickable* temp = pickable_;
  pickable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_pickable(::amarlon::proto::ActorData_Pickable* pickable) {
  delete pickable_;
  pickable_ = pickable;
  if (pickable) {
    set_has_pickable();
  } else {
    clear_has_pickable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.proto.ActorData.pickable)
}

// -------------------------------------------------------------------

// ActorsData

// repeated .amarlon.proto.ActorData actor = 1;
inline int ActorsData::actor_size() const {
  return actor_.size();
}
inline void ActorsData::clear_actor() {
  actor_.Clear();
}
inline const ::amarlon::proto::ActorData& ActorsData::actor(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.proto.ActorsData.actor)
  return actor_.Get(index);
}
inline ::amarlon::proto::ActorData* ActorsData::mutable_actor(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.proto.ActorsData.actor)
  return actor_.Mutable(index);
}
inline ::amarlon::proto::ActorData* ActorsData::add_actor() {
  // @@protoc_insertion_point(field_add:amarlon.proto.ActorsData.actor)
  return actor_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >*
ActorsData::mutable_actor() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.proto.ActorsData.actor)
  return &actor_;
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::proto::ActorData >&
ActorsData::actor() const {
  // @@protoc_insertion_point(field_list:amarlon.proto.ActorsData.actor)
  return actor_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace amarlon

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_actors_2eproto__INCLUDED
