// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: actor.proto

#ifndef PROTOBUF_actor_2eproto__INCLUDED
#define PROTOBUF_actor_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "spell.pb.h"
#include "item_type.pb.h"
#include "drop_rule.pb.h"
#include "utils.pb.h"
// @@protoc_insertion_point(includes)

namespace amarlon {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_actor_2eproto();
void protobuf_AssignDesc_actor_2eproto();
void protobuf_ShutdownFile_actor_2eproto();

class AiData;
class CharacterData;
class DestroyableData;
class InventoryData;
class OpenableData;
class PickableData;
class TalkerData;
class TrapData;
class WearerData;
class StatusEffectData;
class ActorData;

// ===================================================================

class AiData : public ::google::protobuf::Message {
 public:
  AiData();
  virtual ~AiData();

  AiData(const AiData& from);

  inline AiData& operator=(const AiData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AiData& default_instance();

  void Swap(AiData* other);

  // implements Message ----------------------------------------------

  AiData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AiData& from);
  void MergeFrom(const AiData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // required int32 script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline ::google::protobuf::int32 script() const;
  inline void set_script(::google::protobuf::int32 value);

  // required int32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.AiData)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int32 script_;
  ::google::protobuf::int32 type_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static AiData* default_instance_;
};
// -------------------------------------------------------------------

class CharacterData : public ::google::protobuf::Message {
 public:
  CharacterData();
  virtual ~CharacterData();

  CharacterData(const CharacterData& from);

  inline CharacterData& operator=(const CharacterData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterData& default_instance();

  void Swap(CharacterData* other);

  // implements Message ----------------------------------------------

  CharacterData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterData& from);
  void MergeFrom(const CharacterData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // required int32 hp = 2;
  inline bool has_hp() const;
  inline void clear_hp();
  static const int kHpFieldNumber = 2;
  inline ::google::protobuf::int32 hp() const;
  inline void set_hp(::google::protobuf::int32 value);

  // required int32 maxHP = 3;
  inline bool has_maxhp() const;
  inline void clear_maxhp();
  static const int kMaxHPFieldNumber = 3;
  inline ::google::protobuf::int32 maxhp() const;
  inline void set_maxhp(::google::protobuf::int32 value);

  // required int32 baseAC = 4;
  inline bool has_baseac() const;
  inline void clear_baseac();
  static const int kBaseACFieldNumber = 4;
  inline ::google::protobuf::int32 baseac() const;
  inline void set_baseac(::google::protobuf::int32 value);

  // required int32 experience = 5;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 5;
  inline ::google::protobuf::int32 experience() const;
  inline void set_experience(::google::protobuf::int32 value);

  // required int32 classType = 6;
  inline bool has_classtype() const;
  inline void clear_classtype();
  static const int kClassTypeFieldNumber = 6;
  inline ::google::protobuf::int32 classtype() const;
  inline void set_classtype(::google::protobuf::int32 value);

  // required int32 raceType = 7;
  inline bool has_racetype() const;
  inline void clear_racetype();
  static const int kRaceTypeFieldNumber = 7;
  inline ::google::protobuf::int32 racetype() const;
  inline void set_racetype(::google::protobuf::int32 value);

  // required int32 speed = 8;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 8;
  inline ::google::protobuf::int32 speed() const;
  inline void set_speed(::google::protobuf::int32 value);

  // required int32 movePoints = 9;
  inline bool has_movepoints() const;
  inline void clear_movepoints();
  static const int kMovePointsFieldNumber = 9;
  inline ::google::protobuf::int32 movepoints() const;
  inline void set_movepoints(::google::protobuf::int32 value);

  // required int32 team = 10;
  inline bool has_team() const;
  inline void clear_team();
  static const int kTeamFieldNumber = 10;
  inline ::google::protobuf::int32 team() const;
  inline void set_team(::google::protobuf::int32 value);

  // required int32 morale = 11;
  inline bool has_morale() const;
  inline void clear_morale();
  static const int kMoraleFieldNumber = 11;
  inline ::google::protobuf::int32 morale() const;
  inline void set_morale(::google::protobuf::int32 value);

  // required string damage = 12;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 12;
  inline const ::std::string& damage() const;
  inline void set_damage(const ::std::string& value);
  inline void set_damage(const char* value);
  inline void set_damage(const char* value, size_t size);
  inline ::std::string* mutable_damage();
  inline ::std::string* release_damage();
  inline void set_allocated_damage(::std::string* damage);

  // required .amarlon.SpellBookData spellbook = 13;
  inline bool has_spellbook() const;
  inline void clear_spellbook();
  static const int kSpellbookFieldNumber = 13;
  inline const ::amarlon::SpellBookData& spellbook() const;
  inline ::amarlon::SpellBookData* mutable_spellbook();
  inline ::amarlon::SpellBookData* release_spellbook();
  inline void set_allocated_spellbook(::amarlon::SpellBookData* spellbook);

  // required int32 characterType = 14;
  inline bool has_charactertype() const;
  inline void clear_charactertype();
  static const int kCharacterTypeFieldNumber = 14;
  inline ::google::protobuf::int32 charactertype() const;
  inline void set_charactertype(::google::protobuf::int32 value);

  // required int32 uses_count = 15;
  inline bool has_uses_count() const;
  inline void clear_uses_count();
  static const int kUsesCountFieldNumber = 15;
  inline ::google::protobuf::int32 uses_count() const;
  inline void set_uses_count(::google::protobuf::int32 value);

  // repeated .amarlon.IntIntPair skills = 16;
  inline int skills_size() const;
  inline void clear_skills();
  static const int kSkillsFieldNumber = 16;
  inline const ::amarlon::IntIntPair& skills(int index) const;
  inline ::amarlon::IntIntPair* mutable_skills(int index);
  inline ::amarlon::IntIntPair* add_skills();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >&
      skills() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >*
      mutable_skills();

  // repeated .amarlon.IntIntPair abilityScores = 17;
  inline int abilityscores_size() const;
  inline void clear_abilityscores();
  static const int kAbilityScoresFieldNumber = 17;
  inline const ::amarlon::IntIntPair& abilityscores(int index) const;
  inline ::amarlon::IntIntPair* mutable_abilityscores(int index);
  inline ::amarlon::IntIntPair* add_abilityscores();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >&
      abilityscores() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >*
      mutable_abilityscores();

  // repeated string modifiers = 18;
  inline int modifiers_size() const;
  inline void clear_modifiers();
  static const int kModifiersFieldNumber = 18;
  inline const ::std::string& modifiers(int index) const;
  inline ::std::string* mutable_modifiers(int index);
  inline void set_modifiers(int index, const ::std::string& value);
  inline void set_modifiers(int index, const char* value);
  inline void set_modifiers(int index, const char* value, size_t size);
  inline ::std::string* add_modifiers();
  inline void add_modifiers(const ::std::string& value);
  inline void add_modifiers(const char* value);
  inline void add_modifiers(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& modifiers() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_modifiers();

  // @@protoc_insertion_point(class_scope:amarlon.CharacterData)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_hp();
  inline void clear_has_hp();
  inline void set_has_maxhp();
  inline void clear_has_maxhp();
  inline void set_has_baseac();
  inline void clear_has_baseac();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_classtype();
  inline void clear_has_classtype();
  inline void set_has_racetype();
  inline void clear_has_racetype();
  inline void set_has_speed();
  inline void clear_has_speed();
  inline void set_has_movepoints();
  inline void clear_has_movepoints();
  inline void set_has_team();
  inline void clear_has_team();
  inline void set_has_morale();
  inline void clear_has_morale();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_spellbook();
  inline void clear_has_spellbook();
  inline void set_has_charactertype();
  inline void clear_has_charactertype();
  inline void set_has_uses_count();
  inline void clear_has_uses_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 level_;
  ::google::protobuf::int32 hp_;
  ::google::protobuf::int32 maxhp_;
  ::google::protobuf::int32 baseac_;
  ::google::protobuf::int32 experience_;
  ::google::protobuf::int32 classtype_;
  ::google::protobuf::int32 racetype_;
  ::google::protobuf::int32 speed_;
  ::google::protobuf::int32 movepoints_;
  ::google::protobuf::int32 team_;
  ::std::string* damage_;
  ::google::protobuf::int32 morale_;
  ::google::protobuf::int32 charactertype_;
  ::amarlon::SpellBookData* spellbook_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair > skills_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair > abilityscores_;
  ::google::protobuf::RepeatedPtrField< ::std::string> modifiers_;
  ::google::protobuf::int32 uses_count_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static CharacterData* default_instance_;
};
// -------------------------------------------------------------------

class DestroyableData : public ::google::protobuf::Message {
 public:
  DestroyableData();
  virtual ~DestroyableData();

  DestroyableData(const DestroyableData& from);

  inline DestroyableData& operator=(const DestroyableData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DestroyableData& default_instance();

  void Swap(DestroyableData* other);

  // implements Message ----------------------------------------------

  DestroyableData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DestroyableData& from);
  void MergeFrom(const DestroyableData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .amarlon.DropRule dropRules = 1;
  inline int droprules_size() const;
  inline void clear_droprules();
  static const int kDropRulesFieldNumber = 1;
  inline const ::amarlon::DropRule& droprules(int index) const;
  inline ::amarlon::DropRule* mutable_droprules(int index);
  inline ::amarlon::DropRule* add_droprules();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::DropRule >&
      droprules() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::DropRule >*
      mutable_droprules();

  // @@protoc_insertion_point(class_scope:amarlon.DestroyableData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::DropRule > droprules_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static DestroyableData* default_instance_;
};
// -------------------------------------------------------------------

class InventoryData : public ::google::protobuf::Message {
 public:
  InventoryData();
  virtual ~InventoryData();

  InventoryData(const InventoryData& from);

  inline InventoryData& operator=(const InventoryData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InventoryData& default_instance();

  void Swap(InventoryData* other);

  // implements Message ----------------------------------------------

  InventoryData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InventoryData& from);
  void MergeFrom(const InventoryData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 slotCount = 1;
  inline bool has_slotcount() const;
  inline void clear_slotcount();
  static const int kSlotCountFieldNumber = 1;
  inline ::google::protobuf::int32 slotcount() const;
  inline void set_slotcount(::google::protobuf::int32 value);

  // repeated .amarlon.ActorData items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::amarlon::ActorData& items(int index) const;
  inline ::amarlon::ActorData* mutable_items(int index);
  inline ::amarlon::ActorData* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:amarlon.InventoryData)
 private:
  inline void set_has_slotcount();
  inline void clear_has_slotcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData > items_;
  ::google::protobuf::int32 slotcount_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static InventoryData* default_instance_;
};
// -------------------------------------------------------------------

class OpenableData : public ::google::protobuf::Message {
 public:
  OpenableData();
  virtual ~OpenableData();

  OpenableData(const OpenableData& from);

  inline OpenableData& operator=(const OpenableData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenableData& default_instance();

  void Swap(OpenableData* other);

  // implements Message ----------------------------------------------

  OpenableData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenableData& from);
  void MergeFrom(const OpenableData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool locked = 1;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 1;
  inline bool locked() const;
  inline void set_locked(bool value);

  // required bool closed = 2;
  inline bool has_closed() const;
  inline void clear_closed();
  static const int kClosedFieldNumber = 2;
  inline bool closed() const;
  inline void set_closed(bool value);

  // required int32 lock_id = 3;
  inline bool has_lock_id() const;
  inline void clear_lock_id();
  static const int kLockIdFieldNumber = 3;
  inline ::google::protobuf::int32 lock_id() const;
  inline void set_lock_id(::google::protobuf::int32 value);

  // required int32 lock_level = 4;
  inline bool has_lock_level() const;
  inline void clear_lock_level();
  static const int kLockLevelFieldNumber = 4;
  inline ::google::protobuf::int32 lock_level() const;
  inline void set_lock_level(::google::protobuf::int32 value);

  // required int32 script_id = 5;
  inline bool has_script_id() const;
  inline void clear_script_id();
  static const int kScriptIdFieldNumber = 5;
  inline ::google::protobuf::int32 script_id() const;
  inline void set_script_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.OpenableData)
 private:
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_closed();
  inline void clear_has_closed();
  inline void set_has_lock_id();
  inline void clear_has_lock_id();
  inline void set_has_lock_level();
  inline void clear_has_lock_level();
  inline void set_has_script_id();
  inline void clear_has_script_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool locked_;
  bool closed_;
  ::google::protobuf::int32 lock_id_;
  ::google::protobuf::int32 lock_level_;
  ::google::protobuf::int32 script_id_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static OpenableData* default_instance_;
};
// -------------------------------------------------------------------

class PickableData : public ::google::protobuf::Message {
 public:
  PickableData();
  virtual ~PickableData();

  PickableData(const PickableData& from);

  inline PickableData& operator=(const PickableData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PickableData& default_instance();

  void Swap(PickableData* other);

  // implements Message ----------------------------------------------

  PickableData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PickableData& from);
  void MergeFrom(const PickableData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool stackable = 1;
  inline bool has_stackable() const;
  inline void clear_stackable();
  static const int kStackableFieldNumber = 1;
  inline bool stackable() const;
  inline void set_stackable(bool value);

  // required int32 amount = 2;
  inline bool has_amount() const;
  inline void clear_amount();
  static const int kAmountFieldNumber = 2;
  inline ::google::protobuf::int32 amount() const;
  inline void set_amount(::google::protobuf::int32 value);

  // required int32 item_slot = 3;
  inline bool has_item_slot() const;
  inline void clear_item_slot();
  static const int kItemSlotFieldNumber = 3;
  inline ::google::protobuf::int32 item_slot() const;
  inline void set_item_slot(::google::protobuf::int32 value);

  // required int32 armor_class = 4;
  inline bool has_armor_class() const;
  inline void clear_armor_class();
  static const int kArmorClassFieldNumber = 4;
  inline ::google::protobuf::int32 armor_class() const;
  inline void set_armor_class(::google::protobuf::int32 value);

  // required int32 weight = 5;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 5;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // required int32 price = 6;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 6;
  inline ::google::protobuf::int32 price() const;
  inline void set_price(::google::protobuf::int32 value);

  // required int32 target_type = 7;
  inline bool has_target_type() const;
  inline void clear_target_type();
  static const int kTargetTypeFieldNumber = 7;
  inline ::google::protobuf::int32 target_type() const;
  inline void set_target_type(::google::protobuf::int32 value);

  // required string damage = 8;
  inline bool has_damage() const;
  inline void clear_damage();
  static const int kDamageFieldNumber = 8;
  inline const ::std::string& damage() const;
  inline void set_damage(const ::std::string& value);
  inline void set_damage(const char* value);
  inline void set_damage(const char* value, size_t size);
  inline ::std::string* mutable_damage();
  inline ::std::string* release_damage();
  inline void set_allocated_damage(::std::string* damage);

  // required int32 script_id = 9;
  inline bool has_script_id() const;
  inline void clear_script_id();
  static const int kScriptIdFieldNumber = 9;
  inline ::google::protobuf::int32 script_id() const;
  inline void set_script_id(::google::protobuf::int32 value);

  // required int32 range = 10;
  inline bool has_range() const;
  inline void clear_range();
  static const int kRangeFieldNumber = 10;
  inline ::google::protobuf::int32 range() const;
  inline void set_range(::google::protobuf::int32 value);

  // required int32 radius = 11;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 11;
  inline ::google::protobuf::int32 radius() const;
  inline void set_radius(::google::protobuf::int32 value);

  // required .amarlon.ItemTypeData item_type = 12;
  inline bool has_item_type() const;
  inline void clear_item_type();
  static const int kItemTypeFieldNumber = 12;
  inline const ::amarlon::ItemTypeData& item_type() const;
  inline ::amarlon::ItemTypeData* mutable_item_type();
  inline ::amarlon::ItemTypeData* release_item_type();
  inline void set_allocated_item_type(::amarlon::ItemTypeData* item_type);

  // required int32 uses_count = 13;
  inline bool has_uses_count() const;
  inline void clear_uses_count();
  static const int kUsesCountFieldNumber = 13;
  inline ::google::protobuf::int32 uses_count() const;
  inline void set_uses_count(::google::protobuf::int32 value);

  // required int32 spell_id = 14;
  inline bool has_spell_id() const;
  inline void clear_spell_id();
  static const int kSpellIdFieldNumber = 14;
  inline ::google::protobuf::int32 spell_id() const;
  inline void set_spell_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.PickableData)
 private:
  inline void set_has_stackable();
  inline void clear_has_stackable();
  inline void set_has_amount();
  inline void clear_has_amount();
  inline void set_has_item_slot();
  inline void clear_has_item_slot();
  inline void set_has_armor_class();
  inline void clear_has_armor_class();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_target_type();
  inline void clear_has_target_type();
  inline void set_has_damage();
  inline void clear_has_damage();
  inline void set_has_script_id();
  inline void clear_has_script_id();
  inline void set_has_range();
  inline void clear_has_range();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_item_type();
  inline void clear_has_item_type();
  inline void set_has_uses_count();
  inline void clear_has_uses_count();
  inline void set_has_spell_id();
  inline void clear_has_spell_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool stackable_;
  ::google::protobuf::int32 amount_;
  ::google::protobuf::int32 item_slot_;
  ::google::protobuf::int32 armor_class_;
  ::google::protobuf::int32 weight_;
  ::google::protobuf::int32 price_;
  ::std::string* damage_;
  ::google::protobuf::int32 target_type_;
  ::google::protobuf::int32 script_id_;
  ::google::protobuf::int32 range_;
  ::google::protobuf::int32 radius_;
  ::amarlon::ItemTypeData* item_type_;
  ::google::protobuf::int32 uses_count_;
  ::google::protobuf::int32 spell_id_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static PickableData* default_instance_;
};
// -------------------------------------------------------------------

class TalkerData : public ::google::protobuf::Message {
 public:
  TalkerData();
  virtual ~TalkerData();

  TalkerData(const TalkerData& from);

  inline TalkerData& operator=(const TalkerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TalkerData& default_instance();

  void Swap(TalkerData* other);

  // implements Message ----------------------------------------------

  TalkerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TalkerData& from);
  void MergeFrom(const TalkerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:amarlon.TalkerData)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static TalkerData* default_instance_;
};
// -------------------------------------------------------------------

class TrapData : public ::google::protobuf::Message {
 public:
  TrapData();
  virtual ~TrapData();

  TrapData(const TrapData& from);

  inline TrapData& operator=(const TrapData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrapData& default_instance();

  void Swap(TrapData* other);

  // implements Message ----------------------------------------------

  TrapData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TrapData& from);
  void MergeFrom(const TrapData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 difficulty = 2;
  inline bool has_difficulty() const;
  inline void clear_difficulty();
  static const int kDifficultyFieldNumber = 2;
  inline ::google::protobuf::int32 difficulty() const;
  inline void set_difficulty(::google::protobuf::int32 value);

  // required bool is_armed = 3;
  inline bool has_is_armed() const;
  inline void clear_is_armed();
  static const int kIsArmedFieldNumber = 3;
  inline bool is_armed() const;
  inline void set_is_armed(bool value);

  // required bool is_detected = 4;
  inline bool has_is_detected() const;
  inline void clear_is_detected();
  static const int kIsDetectedFieldNumber = 4;
  inline bool is_detected() const;
  inline void set_is_detected(bool value);

  // @@protoc_insertion_point(class_scope:amarlon.TrapData)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_difficulty();
  inline void clear_has_difficulty();
  inline void set_has_is_armed();
  inline void clear_has_is_armed();
  inline void set_has_is_detected();
  inline void clear_has_is_detected();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 difficulty_;
  bool is_armed_;
  bool is_detected_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static TrapData* default_instance_;
};
// -------------------------------------------------------------------

class WearerData : public ::google::protobuf::Message {
 public:
  WearerData();
  virtual ~WearerData();

  WearerData(const WearerData& from);

  inline WearerData& operator=(const WearerData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WearerData& default_instance();

  void Swap(WearerData* other);

  // implements Message ----------------------------------------------

  WearerData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WearerData& from);
  void MergeFrom(const WearerData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 item_slots = 1;
  inline int item_slots_size() const;
  inline void clear_item_slots();
  static const int kItemSlotsFieldNumber = 1;
  inline ::google::protobuf::int32 item_slots(int index) const;
  inline void set_item_slots(int index, ::google::protobuf::int32 value);
  inline void add_item_slots(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      item_slots() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_item_slots();

  // repeated .amarlon.ActorData equipped_items = 2;
  inline int equipped_items_size() const;
  inline void clear_equipped_items();
  static const int kEquippedItemsFieldNumber = 2;
  inline const ::amarlon::ActorData& equipped_items(int index) const;
  inline ::amarlon::ActorData* mutable_equipped_items(int index);
  inline ::amarlon::ActorData* add_equipped_items();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >&
      equipped_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >*
      mutable_equipped_items();

  // @@protoc_insertion_point(class_scope:amarlon.WearerData)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > item_slots_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData > equipped_items_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static WearerData* default_instance_;
};
// -------------------------------------------------------------------

class StatusEffectData : public ::google::protobuf::Message {
 public:
  StatusEffectData();
  virtual ~StatusEffectData();

  StatusEffectData(const StatusEffectData& from);

  inline StatusEffectData& operator=(const StatusEffectData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusEffectData& default_instance();

  void Swap(StatusEffectData* other);

  // implements Message ----------------------------------------------

  StatusEffectData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatusEffectData& from);
  void MergeFrom(const StatusEffectData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // required string script = 3;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 3;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const char* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // @@protoc_insertion_point(class_scope:amarlon.StatusEffectData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_script();
  inline void clear_has_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* script_;
  ::google::protobuf::int32 duration_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static StatusEffectData* default_instance_;
};
// -------------------------------------------------------------------

class ActorData : public ::google::protobuf::Message {
 public:
  ActorData();
  virtual ~ActorData();

  ActorData(const ActorData& from);

  inline ActorData& operator=(const ActorData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActorData& default_instance();

  void Swap(ActorData* other);

  // implements Message ----------------------------------------------

  ActorData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActorData& from);
  void MergeFrom(const ActorData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 actor_type = 1;
  inline bool has_actor_type() const;
  inline void clear_actor_type();
  static const int kActorTypeFieldNumber = 1;
  inline ::google::protobuf::int32 actor_type() const;
  inline void set_actor_type(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string description = 3;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 3;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required int32 x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 flags = 6;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 6;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);

  // required bool is_fov_only = 7;
  inline bool has_is_fov_only() const;
  inline void clear_is_fov_only();
  static const int kIsFovOnlyFieldNumber = 7;
  inline bool is_fov_only() const;
  inline void set_is_fov_only(bool value);

  // required bool is_transparent = 8;
  inline bool has_is_transparent() const;
  inline void clear_is_transparent();
  static const int kIsTransparentFieldNumber = 8;
  inline bool is_transparent() const;
  inline void set_is_transparent(bool value);

  // required bool is_blocking = 9;
  inline bool has_is_blocking() const;
  inline void clear_is_blocking();
  static const int kIsBlockingFieldNumber = 9;
  inline bool is_blocking() const;
  inline void set_is_blocking(bool value);

  // required string symbol = 10;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 10;
  inline const ::std::string& symbol() const;
  inline void set_symbol(const ::std::string& value);
  inline void set_symbol(const char* value);
  inline void set_symbol(const char* value, size_t size);
  inline ::std::string* mutable_symbol();
  inline ::std::string* release_symbol();
  inline void set_allocated_symbol(::std::string* symbol);

  // required int32 render_priority = 11;
  inline bool has_render_priority() const;
  inline void clear_render_priority();
  static const int kRenderPriorityFieldNumber = 11;
  inline ::google::protobuf::int32 render_priority() const;
  inline void set_render_priority(::google::protobuf::int32 value);

  // required string color = 12;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 12;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // repeated .amarlon.StatusEffectData effects = 13;
  inline int effects_size() const;
  inline void clear_effects();
  static const int kEffectsFieldNumber = 13;
  inline const ::amarlon::StatusEffectData& effects(int index) const;
  inline ::amarlon::StatusEffectData* mutable_effects(int index);
  inline ::amarlon::StatusEffectData* add_effects();
  inline const ::google::protobuf::RepeatedPtrField< ::amarlon::StatusEffectData >&
      effects() const;
  inline ::google::protobuf::RepeatedPtrField< ::amarlon::StatusEffectData >*
      mutable_effects();

  // optional .amarlon.AiData ai = 14;
  inline bool has_ai() const;
  inline void clear_ai();
  static const int kAiFieldNumber = 14;
  inline const ::amarlon::AiData& ai() const;
  inline ::amarlon::AiData* mutable_ai();
  inline ::amarlon::AiData* release_ai();
  inline void set_allocated_ai(::amarlon::AiData* ai);

  // optional .amarlon.CharacterData character = 15;
  inline bool has_character() const;
  inline void clear_character();
  static const int kCharacterFieldNumber = 15;
  inline const ::amarlon::CharacterData& character() const;
  inline ::amarlon::CharacterData* mutable_character();
  inline ::amarlon::CharacterData* release_character();
  inline void set_allocated_character(::amarlon::CharacterData* character);

  // optional .amarlon.DestroyableData destroyable = 16;
  inline bool has_destroyable() const;
  inline void clear_destroyable();
  static const int kDestroyableFieldNumber = 16;
  inline const ::amarlon::DestroyableData& destroyable() const;
  inline ::amarlon::DestroyableData* mutable_destroyable();
  inline ::amarlon::DestroyableData* release_destroyable();
  inline void set_allocated_destroyable(::amarlon::DestroyableData* destroyable);

  // optional .amarlon.InventoryData inventory = 17;
  inline bool has_inventory() const;
  inline void clear_inventory();
  static const int kInventoryFieldNumber = 17;
  inline const ::amarlon::InventoryData& inventory() const;
  inline ::amarlon::InventoryData* mutable_inventory();
  inline ::amarlon::InventoryData* release_inventory();
  inline void set_allocated_inventory(::amarlon::InventoryData* inventory);

  // optional .amarlon.OpenableData openable = 18;
  inline bool has_openable() const;
  inline void clear_openable();
  static const int kOpenableFieldNumber = 18;
  inline const ::amarlon::OpenableData& openable() const;
  inline ::amarlon::OpenableData* mutable_openable();
  inline ::amarlon::OpenableData* release_openable();
  inline void set_allocated_openable(::amarlon::OpenableData* openable);

  // optional .amarlon.PickableData pickable = 19;
  inline bool has_pickable() const;
  inline void clear_pickable();
  static const int kPickableFieldNumber = 19;
  inline const ::amarlon::PickableData& pickable() const;
  inline ::amarlon::PickableData* mutable_pickable();
  inline ::amarlon::PickableData* release_pickable();
  inline void set_allocated_pickable(::amarlon::PickableData* pickable);

  // optional .amarlon.TrapData trap = 20;
  inline bool has_trap() const;
  inline void clear_trap();
  static const int kTrapFieldNumber = 20;
  inline const ::amarlon::TrapData& trap() const;
  inline ::amarlon::TrapData* mutable_trap();
  inline ::amarlon::TrapData* release_trap();
  inline void set_allocated_trap(::amarlon::TrapData* trap);

  // optional .amarlon.WearerData wearer = 21;
  inline bool has_wearer() const;
  inline void clear_wearer();
  static const int kWearerFieldNumber = 21;
  inline const ::amarlon::WearerData& wearer() const;
  inline ::amarlon::WearerData* mutable_wearer();
  inline ::amarlon::WearerData* release_wearer();
  inline void set_allocated_wearer(::amarlon::WearerData* wearer);

  // optional .amarlon.TalkerData talker = 22;
  inline bool has_talker() const;
  inline void clear_talker();
  static const int kTalkerFieldNumber = 22;
  inline const ::amarlon::TalkerData& talker() const;
  inline ::amarlon::TalkerData* mutable_talker();
  inline ::amarlon::TalkerData* release_talker();
  inline void set_allocated_talker(::amarlon::TalkerData* talker);

  // @@protoc_insertion_point(class_scope:amarlon.ActorData)
 private:
  inline void set_has_actor_type();
  inline void clear_has_actor_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_is_fov_only();
  inline void clear_has_is_fov_only();
  inline void set_has_is_transparent();
  inline void clear_has_is_transparent();
  inline void set_has_is_blocking();
  inline void clear_has_is_blocking();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_render_priority();
  inline void clear_has_render_priority();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_ai();
  inline void clear_has_ai();
  inline void set_has_character();
  inline void clear_has_character();
  inline void set_has_destroyable();
  inline void clear_has_destroyable();
  inline void set_has_inventory();
  inline void clear_has_inventory();
  inline void set_has_openable();
  inline void clear_has_openable();
  inline void set_has_pickable();
  inline void clear_has_pickable();
  inline void set_has_trap();
  inline void clear_has_trap();
  inline void set_has_wearer();
  inline void clear_has_wearer();
  inline void set_has_talker();
  inline void clear_has_talker();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::google::protobuf::int32 actor_type_;
  ::google::protobuf::int32 x_;
  ::std::string* description_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 flags_;
  bool is_fov_only_;
  bool is_transparent_;
  bool is_blocking_;
  ::google::protobuf::int32 render_priority_;
  ::std::string* symbol_;
  ::std::string* color_;
  ::google::protobuf::RepeatedPtrField< ::amarlon::StatusEffectData > effects_;
  ::amarlon::AiData* ai_;
  ::amarlon::CharacterData* character_;
  ::amarlon::DestroyableData* destroyable_;
  ::amarlon::InventoryData* inventory_;
  ::amarlon::OpenableData* openable_;
  ::amarlon::PickableData* pickable_;
  ::amarlon::TrapData* trap_;
  ::amarlon::WearerData* wearer_;
  ::amarlon::TalkerData* talker_;
  friend void  protobuf_AddDesc_actor_2eproto();
  friend void protobuf_AssignDesc_actor_2eproto();
  friend void protobuf_ShutdownFile_actor_2eproto();

  void InitAsDefaultInstance();
  static ActorData* default_instance_;
};
// ===================================================================


// ===================================================================

// AiData

// required fixed32 flags = 1;
inline bool AiData::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AiData::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AiData::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AiData::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 AiData::flags() const {
  // @@protoc_insertion_point(field_get:amarlon.AiData.flags)
  return flags_;
}
inline void AiData::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:amarlon.AiData.flags)
}

// required int32 script = 2;
inline bool AiData::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AiData::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AiData::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AiData::clear_script() {
  script_ = 0;
  clear_has_script();
}
inline ::google::protobuf::int32 AiData::script() const {
  // @@protoc_insertion_point(field_get:amarlon.AiData.script)
  return script_;
}
inline void AiData::set_script(::google::protobuf::int32 value) {
  set_has_script();
  script_ = value;
  // @@protoc_insertion_point(field_set:amarlon.AiData.script)
}

// required int32 type = 3;
inline bool AiData::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AiData::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AiData::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AiData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 AiData::type() const {
  // @@protoc_insertion_point(field_get:amarlon.AiData.type)
  return type_;
}
inline void AiData::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:amarlon.AiData.type)
}

// -------------------------------------------------------------------

// CharacterData

// required int32 level = 1;
inline bool CharacterData::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterData::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterData::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterData::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 CharacterData::level() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.level)
  return level_;
}
inline void CharacterData::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.level)
}

// required int32 hp = 2;
inline bool CharacterData::has_hp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterData::set_has_hp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterData::clear_has_hp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterData::clear_hp() {
  hp_ = 0;
  clear_has_hp();
}
inline ::google::protobuf::int32 CharacterData::hp() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.hp)
  return hp_;
}
inline void CharacterData::set_hp(::google::protobuf::int32 value) {
  set_has_hp();
  hp_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.hp)
}

// required int32 maxHP = 3;
inline bool CharacterData::has_maxhp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharacterData::set_has_maxhp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharacterData::clear_has_maxhp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharacterData::clear_maxhp() {
  maxhp_ = 0;
  clear_has_maxhp();
}
inline ::google::protobuf::int32 CharacterData::maxhp() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.maxHP)
  return maxhp_;
}
inline void CharacterData::set_maxhp(::google::protobuf::int32 value) {
  set_has_maxhp();
  maxhp_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.maxHP)
}

// required int32 baseAC = 4;
inline bool CharacterData::has_baseac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharacterData::set_has_baseac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharacterData::clear_has_baseac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharacterData::clear_baseac() {
  baseac_ = 0;
  clear_has_baseac();
}
inline ::google::protobuf::int32 CharacterData::baseac() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.baseAC)
  return baseac_;
}
inline void CharacterData::set_baseac(::google::protobuf::int32 value) {
  set_has_baseac();
  baseac_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.baseAC)
}

// required int32 experience = 5;
inline bool CharacterData::has_experience() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharacterData::set_has_experience() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharacterData::clear_has_experience() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharacterData::clear_experience() {
  experience_ = 0;
  clear_has_experience();
}
inline ::google::protobuf::int32 CharacterData::experience() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.experience)
  return experience_;
}
inline void CharacterData::set_experience(::google::protobuf::int32 value) {
  set_has_experience();
  experience_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.experience)
}

// required int32 classType = 6;
inline bool CharacterData::has_classtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharacterData::set_has_classtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharacterData::clear_has_classtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharacterData::clear_classtype() {
  classtype_ = 0;
  clear_has_classtype();
}
inline ::google::protobuf::int32 CharacterData::classtype() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.classType)
  return classtype_;
}
inline void CharacterData::set_classtype(::google::protobuf::int32 value) {
  set_has_classtype();
  classtype_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.classType)
}

// required int32 raceType = 7;
inline bool CharacterData::has_racetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharacterData::set_has_racetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharacterData::clear_has_racetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharacterData::clear_racetype() {
  racetype_ = 0;
  clear_has_racetype();
}
inline ::google::protobuf::int32 CharacterData::racetype() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.raceType)
  return racetype_;
}
inline void CharacterData::set_racetype(::google::protobuf::int32 value) {
  set_has_racetype();
  racetype_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.raceType)
}

// required int32 speed = 8;
inline bool CharacterData::has_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharacterData::set_has_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharacterData::clear_has_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharacterData::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline ::google::protobuf::int32 CharacterData::speed() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.speed)
  return speed_;
}
inline void CharacterData::set_speed(::google::protobuf::int32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.speed)
}

// required int32 movePoints = 9;
inline bool CharacterData::has_movepoints() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharacterData::set_has_movepoints() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharacterData::clear_has_movepoints() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharacterData::clear_movepoints() {
  movepoints_ = 0;
  clear_has_movepoints();
}
inline ::google::protobuf::int32 CharacterData::movepoints() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.movePoints)
  return movepoints_;
}
inline void CharacterData::set_movepoints(::google::protobuf::int32 value) {
  set_has_movepoints();
  movepoints_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.movePoints)
}

// required int32 team = 10;
inline bool CharacterData::has_team() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharacterData::set_has_team() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharacterData::clear_has_team() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharacterData::clear_team() {
  team_ = 0;
  clear_has_team();
}
inline ::google::protobuf::int32 CharacterData::team() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.team)
  return team_;
}
inline void CharacterData::set_team(::google::protobuf::int32 value) {
  set_has_team();
  team_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.team)
}

// required int32 morale = 11;
inline bool CharacterData::has_morale() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharacterData::set_has_morale() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharacterData::clear_has_morale() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharacterData::clear_morale() {
  morale_ = 0;
  clear_has_morale();
}
inline ::google::protobuf::int32 CharacterData::morale() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.morale)
  return morale_;
}
inline void CharacterData::set_morale(::google::protobuf::int32 value) {
  set_has_morale();
  morale_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.morale)
}

// required string damage = 12;
inline bool CharacterData::has_damage() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharacterData::set_has_damage() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharacterData::clear_has_damage() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharacterData::clear_damage() {
  if (damage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_->clear();
  }
  clear_has_damage();
}
inline const ::std::string& CharacterData::damage() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.damage)
  return *damage_;
}
inline void CharacterData::set_damage(const ::std::string& value) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.damage)
}
inline void CharacterData::set_damage(const char* value) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.CharacterData.damage)
}
inline void CharacterData::set_damage(const char* value, size_t size) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.CharacterData.damage)
}
inline ::std::string* CharacterData::mutable_damage() {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.CharacterData.damage)
  return damage_;
}
inline ::std::string* CharacterData::release_damage() {
  clear_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = damage_;
    damage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void CharacterData::set_allocated_damage(::std::string* damage) {
  if (damage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete damage_;
  }
  if (damage) {
    set_has_damage();
    damage_ = damage;
  } else {
    clear_has_damage();
    damage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.CharacterData.damage)
}

// required .amarlon.SpellBookData spellbook = 13;
inline bool CharacterData::has_spellbook() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharacterData::set_has_spellbook() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharacterData::clear_has_spellbook() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharacterData::clear_spellbook() {
  if (spellbook_ != NULL) spellbook_->::amarlon::SpellBookData::Clear();
  clear_has_spellbook();
}
inline const ::amarlon::SpellBookData& CharacterData::spellbook() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.spellbook)
  return spellbook_ != NULL ? *spellbook_ : *default_instance_->spellbook_;
}
inline ::amarlon::SpellBookData* CharacterData::mutable_spellbook() {
  set_has_spellbook();
  if (spellbook_ == NULL) spellbook_ = new ::amarlon::SpellBookData;
  // @@protoc_insertion_point(field_mutable:amarlon.CharacterData.spellbook)
  return spellbook_;
}
inline ::amarlon::SpellBookData* CharacterData::release_spellbook() {
  clear_has_spellbook();
  ::amarlon::SpellBookData* temp = spellbook_;
  spellbook_ = NULL;
  return temp;
}
inline void CharacterData::set_allocated_spellbook(::amarlon::SpellBookData* spellbook) {
  delete spellbook_;
  spellbook_ = spellbook;
  if (spellbook) {
    set_has_spellbook();
  } else {
    clear_has_spellbook();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.CharacterData.spellbook)
}

// required int32 characterType = 14;
inline bool CharacterData::has_charactertype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharacterData::set_has_charactertype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharacterData::clear_has_charactertype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharacterData::clear_charactertype() {
  charactertype_ = 0;
  clear_has_charactertype();
}
inline ::google::protobuf::int32 CharacterData::charactertype() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.characterType)
  return charactertype_;
}
inline void CharacterData::set_charactertype(::google::protobuf::int32 value) {
  set_has_charactertype();
  charactertype_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.characterType)
}

// required int32 uses_count = 15;
inline bool CharacterData::has_uses_count() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CharacterData::set_has_uses_count() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CharacterData::clear_has_uses_count() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CharacterData::clear_uses_count() {
  uses_count_ = 0;
  clear_has_uses_count();
}
inline ::google::protobuf::int32 CharacterData::uses_count() const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.uses_count)
  return uses_count_;
}
inline void CharacterData::set_uses_count(::google::protobuf::int32 value) {
  set_has_uses_count();
  uses_count_ = value;
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.uses_count)
}

// repeated .amarlon.IntIntPair skills = 16;
inline int CharacterData::skills_size() const {
  return skills_.size();
}
inline void CharacterData::clear_skills() {
  skills_.Clear();
}
inline const ::amarlon::IntIntPair& CharacterData::skills(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.skills)
  return skills_.Get(index);
}
inline ::amarlon::IntIntPair* CharacterData::mutable_skills(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.CharacterData.skills)
  return skills_.Mutable(index);
}
inline ::amarlon::IntIntPair* CharacterData::add_skills() {
  // @@protoc_insertion_point(field_add:amarlon.CharacterData.skills)
  return skills_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >&
CharacterData::skills() const {
  // @@protoc_insertion_point(field_list:amarlon.CharacterData.skills)
  return skills_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >*
CharacterData::mutable_skills() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.CharacterData.skills)
  return &skills_;
}

// repeated .amarlon.IntIntPair abilityScores = 17;
inline int CharacterData::abilityscores_size() const {
  return abilityscores_.size();
}
inline void CharacterData::clear_abilityscores() {
  abilityscores_.Clear();
}
inline const ::amarlon::IntIntPair& CharacterData::abilityscores(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.abilityScores)
  return abilityscores_.Get(index);
}
inline ::amarlon::IntIntPair* CharacterData::mutable_abilityscores(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.CharacterData.abilityScores)
  return abilityscores_.Mutable(index);
}
inline ::amarlon::IntIntPair* CharacterData::add_abilityscores() {
  // @@protoc_insertion_point(field_add:amarlon.CharacterData.abilityScores)
  return abilityscores_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >&
CharacterData::abilityscores() const {
  // @@protoc_insertion_point(field_list:amarlon.CharacterData.abilityScores)
  return abilityscores_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::IntIntPair >*
CharacterData::mutable_abilityscores() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.CharacterData.abilityScores)
  return &abilityscores_;
}

// repeated string modifiers = 18;
inline int CharacterData::modifiers_size() const {
  return modifiers_.size();
}
inline void CharacterData::clear_modifiers() {
  modifiers_.Clear();
}
inline const ::std::string& CharacterData::modifiers(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.CharacterData.modifiers)
  return modifiers_.Get(index);
}
inline ::std::string* CharacterData::mutable_modifiers(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.CharacterData.modifiers)
  return modifiers_.Mutable(index);
}
inline void CharacterData::set_modifiers(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:amarlon.CharacterData.modifiers)
  modifiers_.Mutable(index)->assign(value);
}
inline void CharacterData::set_modifiers(int index, const char* value) {
  modifiers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.CharacterData.modifiers)
}
inline void CharacterData::set_modifiers(int index, const char* value, size_t size) {
  modifiers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.CharacterData.modifiers)
}
inline ::std::string* CharacterData::add_modifiers() {
  return modifiers_.Add();
}
inline void CharacterData::add_modifiers(const ::std::string& value) {
  modifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:amarlon.CharacterData.modifiers)
}
inline void CharacterData::add_modifiers(const char* value) {
  modifiers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:amarlon.CharacterData.modifiers)
}
inline void CharacterData::add_modifiers(const char* value, size_t size) {
  modifiers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:amarlon.CharacterData.modifiers)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CharacterData::modifiers() const {
  // @@protoc_insertion_point(field_list:amarlon.CharacterData.modifiers)
  return modifiers_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CharacterData::mutable_modifiers() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.CharacterData.modifiers)
  return &modifiers_;
}

// -------------------------------------------------------------------

// DestroyableData

// repeated .amarlon.DropRule dropRules = 1;
inline int DestroyableData::droprules_size() const {
  return droprules_.size();
}
inline void DestroyableData::clear_droprules() {
  droprules_.Clear();
}
inline const ::amarlon::DropRule& DestroyableData::droprules(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.DestroyableData.dropRules)
  return droprules_.Get(index);
}
inline ::amarlon::DropRule* DestroyableData::mutable_droprules(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.DestroyableData.dropRules)
  return droprules_.Mutable(index);
}
inline ::amarlon::DropRule* DestroyableData::add_droprules() {
  // @@protoc_insertion_point(field_add:amarlon.DestroyableData.dropRules)
  return droprules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::DropRule >&
DestroyableData::droprules() const {
  // @@protoc_insertion_point(field_list:amarlon.DestroyableData.dropRules)
  return droprules_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::DropRule >*
DestroyableData::mutable_droprules() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.DestroyableData.dropRules)
  return &droprules_;
}

// -------------------------------------------------------------------

// InventoryData

// required int32 slotCount = 1;
inline bool InventoryData::has_slotcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InventoryData::set_has_slotcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InventoryData::clear_has_slotcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InventoryData::clear_slotcount() {
  slotcount_ = 0;
  clear_has_slotcount();
}
inline ::google::protobuf::int32 InventoryData::slotcount() const {
  // @@protoc_insertion_point(field_get:amarlon.InventoryData.slotCount)
  return slotcount_;
}
inline void InventoryData::set_slotcount(::google::protobuf::int32 value) {
  set_has_slotcount();
  slotcount_ = value;
  // @@protoc_insertion_point(field_set:amarlon.InventoryData.slotCount)
}

// repeated .amarlon.ActorData items = 2;
inline int InventoryData::items_size() const {
  return items_.size();
}
inline void InventoryData::clear_items() {
  items_.Clear();
}
inline const ::amarlon::ActorData& InventoryData::items(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.InventoryData.items)
  return items_.Get(index);
}
inline ::amarlon::ActorData* InventoryData::mutable_items(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.InventoryData.items)
  return items_.Mutable(index);
}
inline ::amarlon::ActorData* InventoryData::add_items() {
  // @@protoc_insertion_point(field_add:amarlon.InventoryData.items)
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >&
InventoryData::items() const {
  // @@protoc_insertion_point(field_list:amarlon.InventoryData.items)
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >*
InventoryData::mutable_items() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.InventoryData.items)
  return &items_;
}

// -------------------------------------------------------------------

// OpenableData

// required bool locked = 1;
inline bool OpenableData::has_locked() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenableData::set_has_locked() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenableData::clear_has_locked() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenableData::clear_locked() {
  locked_ = false;
  clear_has_locked();
}
inline bool OpenableData::locked() const {
  // @@protoc_insertion_point(field_get:amarlon.OpenableData.locked)
  return locked_;
}
inline void OpenableData::set_locked(bool value) {
  set_has_locked();
  locked_ = value;
  // @@protoc_insertion_point(field_set:amarlon.OpenableData.locked)
}

// required bool closed = 2;
inline bool OpenableData::has_closed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenableData::set_has_closed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenableData::clear_has_closed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenableData::clear_closed() {
  closed_ = false;
  clear_has_closed();
}
inline bool OpenableData::closed() const {
  // @@protoc_insertion_point(field_get:amarlon.OpenableData.closed)
  return closed_;
}
inline void OpenableData::set_closed(bool value) {
  set_has_closed();
  closed_ = value;
  // @@protoc_insertion_point(field_set:amarlon.OpenableData.closed)
}

// required int32 lock_id = 3;
inline bool OpenableData::has_lock_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenableData::set_has_lock_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenableData::clear_has_lock_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenableData::clear_lock_id() {
  lock_id_ = 0;
  clear_has_lock_id();
}
inline ::google::protobuf::int32 OpenableData::lock_id() const {
  // @@protoc_insertion_point(field_get:amarlon.OpenableData.lock_id)
  return lock_id_;
}
inline void OpenableData::set_lock_id(::google::protobuf::int32 value) {
  set_has_lock_id();
  lock_id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.OpenableData.lock_id)
}

// required int32 lock_level = 4;
inline bool OpenableData::has_lock_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenableData::set_has_lock_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenableData::clear_has_lock_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenableData::clear_lock_level() {
  lock_level_ = 0;
  clear_has_lock_level();
}
inline ::google::protobuf::int32 OpenableData::lock_level() const {
  // @@protoc_insertion_point(field_get:amarlon.OpenableData.lock_level)
  return lock_level_;
}
inline void OpenableData::set_lock_level(::google::protobuf::int32 value) {
  set_has_lock_level();
  lock_level_ = value;
  // @@protoc_insertion_point(field_set:amarlon.OpenableData.lock_level)
}

// required int32 script_id = 5;
inline bool OpenableData::has_script_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenableData::set_has_script_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenableData::clear_has_script_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenableData::clear_script_id() {
  script_id_ = 0;
  clear_has_script_id();
}
inline ::google::protobuf::int32 OpenableData::script_id() const {
  // @@protoc_insertion_point(field_get:amarlon.OpenableData.script_id)
  return script_id_;
}
inline void OpenableData::set_script_id(::google::protobuf::int32 value) {
  set_has_script_id();
  script_id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.OpenableData.script_id)
}

// -------------------------------------------------------------------

// PickableData

// required bool stackable = 1;
inline bool PickableData::has_stackable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PickableData::set_has_stackable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PickableData::clear_has_stackable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PickableData::clear_stackable() {
  stackable_ = false;
  clear_has_stackable();
}
inline bool PickableData::stackable() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.stackable)
  return stackable_;
}
inline void PickableData::set_stackable(bool value) {
  set_has_stackable();
  stackable_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.stackable)
}

// required int32 amount = 2;
inline bool PickableData::has_amount() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PickableData::set_has_amount() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PickableData::clear_has_amount() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PickableData::clear_amount() {
  amount_ = 0;
  clear_has_amount();
}
inline ::google::protobuf::int32 PickableData::amount() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.amount)
  return amount_;
}
inline void PickableData::set_amount(::google::protobuf::int32 value) {
  set_has_amount();
  amount_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.amount)
}

// required int32 item_slot = 3;
inline bool PickableData::has_item_slot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PickableData::set_has_item_slot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PickableData::clear_has_item_slot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PickableData::clear_item_slot() {
  item_slot_ = 0;
  clear_has_item_slot();
}
inline ::google::protobuf::int32 PickableData::item_slot() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.item_slot)
  return item_slot_;
}
inline void PickableData::set_item_slot(::google::protobuf::int32 value) {
  set_has_item_slot();
  item_slot_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.item_slot)
}

// required int32 armor_class = 4;
inline bool PickableData::has_armor_class() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PickableData::set_has_armor_class() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PickableData::clear_has_armor_class() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PickableData::clear_armor_class() {
  armor_class_ = 0;
  clear_has_armor_class();
}
inline ::google::protobuf::int32 PickableData::armor_class() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.armor_class)
  return armor_class_;
}
inline void PickableData::set_armor_class(::google::protobuf::int32 value) {
  set_has_armor_class();
  armor_class_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.armor_class)
}

// required int32 weight = 5;
inline bool PickableData::has_weight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PickableData::set_has_weight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PickableData::clear_has_weight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PickableData::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 PickableData::weight() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.weight)
  return weight_;
}
inline void PickableData::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.weight)
}

// required int32 price = 6;
inline bool PickableData::has_price() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PickableData::set_has_price() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PickableData::clear_has_price() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PickableData::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline ::google::protobuf::int32 PickableData::price() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.price)
  return price_;
}
inline void PickableData::set_price(::google::protobuf::int32 value) {
  set_has_price();
  price_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.price)
}

// required int32 target_type = 7;
inline bool PickableData::has_target_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PickableData::set_has_target_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PickableData::clear_has_target_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PickableData::clear_target_type() {
  target_type_ = 0;
  clear_has_target_type();
}
inline ::google::protobuf::int32 PickableData::target_type() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.target_type)
  return target_type_;
}
inline void PickableData::set_target_type(::google::protobuf::int32 value) {
  set_has_target_type();
  target_type_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.target_type)
}

// required string damage = 8;
inline bool PickableData::has_damage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PickableData::set_has_damage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PickableData::clear_has_damage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PickableData::clear_damage() {
  if (damage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_->clear();
  }
  clear_has_damage();
}
inline const ::std::string& PickableData::damage() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.damage)
  return *damage_;
}
inline void PickableData::set_damage(const ::std::string& value) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.PickableData.damage)
}
inline void PickableData::set_damage(const char* value) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.PickableData.damage)
}
inline void PickableData::set_damage(const char* value, size_t size) {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  damage_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.PickableData.damage)
}
inline ::std::string* PickableData::mutable_damage() {
  set_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    damage_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.PickableData.damage)
  return damage_;
}
inline ::std::string* PickableData::release_damage() {
  clear_has_damage();
  if (damage_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = damage_;
    damage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PickableData::set_allocated_damage(::std::string* damage) {
  if (damage_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete damage_;
  }
  if (damage) {
    set_has_damage();
    damage_ = damage;
  } else {
    clear_has_damage();
    damage_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.PickableData.damage)
}

// required int32 script_id = 9;
inline bool PickableData::has_script_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PickableData::set_has_script_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PickableData::clear_has_script_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PickableData::clear_script_id() {
  script_id_ = 0;
  clear_has_script_id();
}
inline ::google::protobuf::int32 PickableData::script_id() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.script_id)
  return script_id_;
}
inline void PickableData::set_script_id(::google::protobuf::int32 value) {
  set_has_script_id();
  script_id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.script_id)
}

// required int32 range = 10;
inline bool PickableData::has_range() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PickableData::set_has_range() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PickableData::clear_has_range() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PickableData::clear_range() {
  range_ = 0;
  clear_has_range();
}
inline ::google::protobuf::int32 PickableData::range() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.range)
  return range_;
}
inline void PickableData::set_range(::google::protobuf::int32 value) {
  set_has_range();
  range_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.range)
}

// required int32 radius = 11;
inline bool PickableData::has_radius() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PickableData::set_has_radius() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PickableData::clear_has_radius() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PickableData::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline ::google::protobuf::int32 PickableData::radius() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.radius)
  return radius_;
}
inline void PickableData::set_radius(::google::protobuf::int32 value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.radius)
}

// required .amarlon.ItemTypeData item_type = 12;
inline bool PickableData::has_item_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PickableData::set_has_item_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PickableData::clear_has_item_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PickableData::clear_item_type() {
  if (item_type_ != NULL) item_type_->::amarlon::ItemTypeData::Clear();
  clear_has_item_type();
}
inline const ::amarlon::ItemTypeData& PickableData::item_type() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.item_type)
  return item_type_ != NULL ? *item_type_ : *default_instance_->item_type_;
}
inline ::amarlon::ItemTypeData* PickableData::mutable_item_type() {
  set_has_item_type();
  if (item_type_ == NULL) item_type_ = new ::amarlon::ItemTypeData;
  // @@protoc_insertion_point(field_mutable:amarlon.PickableData.item_type)
  return item_type_;
}
inline ::amarlon::ItemTypeData* PickableData::release_item_type() {
  clear_has_item_type();
  ::amarlon::ItemTypeData* temp = item_type_;
  item_type_ = NULL;
  return temp;
}
inline void PickableData::set_allocated_item_type(::amarlon::ItemTypeData* item_type) {
  delete item_type_;
  item_type_ = item_type;
  if (item_type) {
    set_has_item_type();
  } else {
    clear_has_item_type();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.PickableData.item_type)
}

// required int32 uses_count = 13;
inline bool PickableData::has_uses_count() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PickableData::set_has_uses_count() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PickableData::clear_has_uses_count() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PickableData::clear_uses_count() {
  uses_count_ = 0;
  clear_has_uses_count();
}
inline ::google::protobuf::int32 PickableData::uses_count() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.uses_count)
  return uses_count_;
}
inline void PickableData::set_uses_count(::google::protobuf::int32 value) {
  set_has_uses_count();
  uses_count_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.uses_count)
}

// required int32 spell_id = 14;
inline bool PickableData::has_spell_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PickableData::set_has_spell_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PickableData::clear_has_spell_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PickableData::clear_spell_id() {
  spell_id_ = 0;
  clear_has_spell_id();
}
inline ::google::protobuf::int32 PickableData::spell_id() const {
  // @@protoc_insertion_point(field_get:amarlon.PickableData.spell_id)
  return spell_id_;
}
inline void PickableData::set_spell_id(::google::protobuf::int32 value) {
  set_has_spell_id();
  spell_id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.PickableData.spell_id)
}

// -------------------------------------------------------------------

// TalkerData

// required int32 id = 1;
inline bool TalkerData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TalkerData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TalkerData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TalkerData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TalkerData::id() const {
  // @@protoc_insertion_point(field_get:amarlon.TalkerData.id)
  return id_;
}
inline void TalkerData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.TalkerData.id)
}

// -------------------------------------------------------------------

// TrapData

// required int32 id = 1;
inline bool TrapData::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrapData::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrapData::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrapData::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 TrapData::id() const {
  // @@protoc_insertion_point(field_get:amarlon.TrapData.id)
  return id_;
}
inline void TrapData::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:amarlon.TrapData.id)
}

// required int32 difficulty = 2;
inline bool TrapData::has_difficulty() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrapData::set_has_difficulty() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrapData::clear_has_difficulty() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrapData::clear_difficulty() {
  difficulty_ = 0;
  clear_has_difficulty();
}
inline ::google::protobuf::int32 TrapData::difficulty() const {
  // @@protoc_insertion_point(field_get:amarlon.TrapData.difficulty)
  return difficulty_;
}
inline void TrapData::set_difficulty(::google::protobuf::int32 value) {
  set_has_difficulty();
  difficulty_ = value;
  // @@protoc_insertion_point(field_set:amarlon.TrapData.difficulty)
}

// required bool is_armed = 3;
inline bool TrapData::has_is_armed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrapData::set_has_is_armed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrapData::clear_has_is_armed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrapData::clear_is_armed() {
  is_armed_ = false;
  clear_has_is_armed();
}
inline bool TrapData::is_armed() const {
  // @@protoc_insertion_point(field_get:amarlon.TrapData.is_armed)
  return is_armed_;
}
inline void TrapData::set_is_armed(bool value) {
  set_has_is_armed();
  is_armed_ = value;
  // @@protoc_insertion_point(field_set:amarlon.TrapData.is_armed)
}

// required bool is_detected = 4;
inline bool TrapData::has_is_detected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrapData::set_has_is_detected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrapData::clear_has_is_detected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrapData::clear_is_detected() {
  is_detected_ = false;
  clear_has_is_detected();
}
inline bool TrapData::is_detected() const {
  // @@protoc_insertion_point(field_get:amarlon.TrapData.is_detected)
  return is_detected_;
}
inline void TrapData::set_is_detected(bool value) {
  set_has_is_detected();
  is_detected_ = value;
  // @@protoc_insertion_point(field_set:amarlon.TrapData.is_detected)
}

// -------------------------------------------------------------------

// WearerData

// repeated int32 item_slots = 1;
inline int WearerData::item_slots_size() const {
  return item_slots_.size();
}
inline void WearerData::clear_item_slots() {
  item_slots_.Clear();
}
inline ::google::protobuf::int32 WearerData::item_slots(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.WearerData.item_slots)
  return item_slots_.Get(index);
}
inline void WearerData::set_item_slots(int index, ::google::protobuf::int32 value) {
  item_slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:amarlon.WearerData.item_slots)
}
inline void WearerData::add_item_slots(::google::protobuf::int32 value) {
  item_slots_.Add(value);
  // @@protoc_insertion_point(field_add:amarlon.WearerData.item_slots)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
WearerData::item_slots() const {
  // @@protoc_insertion_point(field_list:amarlon.WearerData.item_slots)
  return item_slots_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
WearerData::mutable_item_slots() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.WearerData.item_slots)
  return &item_slots_;
}

// repeated .amarlon.ActorData equipped_items = 2;
inline int WearerData::equipped_items_size() const {
  return equipped_items_.size();
}
inline void WearerData::clear_equipped_items() {
  equipped_items_.Clear();
}
inline const ::amarlon::ActorData& WearerData::equipped_items(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.WearerData.equipped_items)
  return equipped_items_.Get(index);
}
inline ::amarlon::ActorData* WearerData::mutable_equipped_items(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.WearerData.equipped_items)
  return equipped_items_.Mutable(index);
}
inline ::amarlon::ActorData* WearerData::add_equipped_items() {
  // @@protoc_insertion_point(field_add:amarlon.WearerData.equipped_items)
  return equipped_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >&
WearerData::equipped_items() const {
  // @@protoc_insertion_point(field_list:amarlon.WearerData.equipped_items)
  return equipped_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::ActorData >*
WearerData::mutable_equipped_items() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.WearerData.equipped_items)
  return &equipped_items_;
}

// -------------------------------------------------------------------

// StatusEffectData

// required string name = 1;
inline bool StatusEffectData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatusEffectData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatusEffectData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatusEffectData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StatusEffectData::name() const {
  // @@protoc_insertion_point(field_get:amarlon.StatusEffectData.name)
  return *name_;
}
inline void StatusEffectData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.StatusEffectData.name)
}
inline void StatusEffectData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.StatusEffectData.name)
}
inline void StatusEffectData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.StatusEffectData.name)
}
inline ::std::string* StatusEffectData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.StatusEffectData.name)
  return name_;
}
inline ::std::string* StatusEffectData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StatusEffectData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.StatusEffectData.name)
}

// required int32 duration = 2;
inline bool StatusEffectData::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatusEffectData::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatusEffectData::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatusEffectData::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 StatusEffectData::duration() const {
  // @@protoc_insertion_point(field_get:amarlon.StatusEffectData.duration)
  return duration_;
}
inline void StatusEffectData::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:amarlon.StatusEffectData.duration)
}

// required string script = 3;
inline bool StatusEffectData::has_script() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatusEffectData::set_has_script() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatusEffectData::clear_has_script() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatusEffectData::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& StatusEffectData::script() const {
  // @@protoc_insertion_point(field_get:amarlon.StatusEffectData.script)
  return *script_;
}
inline void StatusEffectData::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.StatusEffectData.script)
}
inline void StatusEffectData::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.StatusEffectData.script)
}
inline void StatusEffectData::set_script(const char* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.StatusEffectData.script)
}
inline ::std::string* StatusEffectData::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.StatusEffectData.script)
  return script_;
}
inline ::std::string* StatusEffectData::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void StatusEffectData::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.StatusEffectData.script)
}

// -------------------------------------------------------------------

// ActorData

// required int32 actor_type = 1;
inline bool ActorData::has_actor_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActorData::set_has_actor_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActorData::clear_has_actor_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActorData::clear_actor_type() {
  actor_type_ = 0;
  clear_has_actor_type();
}
inline ::google::protobuf::int32 ActorData::actor_type() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.actor_type)
  return actor_type_;
}
inline void ActorData::set_actor_type(::google::protobuf::int32 value) {
  set_has_actor_type();
  actor_type_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.actor_type)
}

// required string name = 2;
inline bool ActorData::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActorData::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActorData::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActorData::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ActorData::name() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.name)
  return *name_;
}
inline void ActorData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.ActorData.name)
}
inline void ActorData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.ActorData.name)
}
inline void ActorData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.ActorData.name)
}
inline ::std::string* ActorData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.name)
  return name_;
}
inline ::std::string* ActorData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActorData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.name)
}

// required string description = 3;
inline bool ActorData::has_description() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActorData::set_has_description() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActorData::clear_has_description() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActorData::clear_description() {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ActorData::description() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.description)
  return *description_;
}
inline void ActorData::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.ActorData.description)
}
inline void ActorData::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.ActorData.description)
}
inline void ActorData::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.ActorData.description)
}
inline ::std::string* ActorData::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    description_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.description)
  return description_;
}
inline ::std::string* ActorData::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActorData::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.description)
}

// required int32 x = 4;
inline bool ActorData::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActorData::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActorData::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActorData::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 ActorData::x() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.x)
  return x_;
}
inline void ActorData::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.x)
}

// required int32 y = 5;
inline bool ActorData::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActorData::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActorData::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActorData::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 ActorData::y() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.y)
  return y_;
}
inline void ActorData::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.y)
}

// required int32 flags = 6;
inline bool ActorData::has_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActorData::set_has_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActorData::clear_has_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActorData::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 ActorData::flags() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.flags)
  return flags_;
}
inline void ActorData::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.flags)
}

// required bool is_fov_only = 7;
inline bool ActorData::has_is_fov_only() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActorData::set_has_is_fov_only() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActorData::clear_has_is_fov_only() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActorData::clear_is_fov_only() {
  is_fov_only_ = false;
  clear_has_is_fov_only();
}
inline bool ActorData::is_fov_only() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.is_fov_only)
  return is_fov_only_;
}
inline void ActorData::set_is_fov_only(bool value) {
  set_has_is_fov_only();
  is_fov_only_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.is_fov_only)
}

// required bool is_transparent = 8;
inline bool ActorData::has_is_transparent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActorData::set_has_is_transparent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActorData::clear_has_is_transparent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActorData::clear_is_transparent() {
  is_transparent_ = false;
  clear_has_is_transparent();
}
inline bool ActorData::is_transparent() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.is_transparent)
  return is_transparent_;
}
inline void ActorData::set_is_transparent(bool value) {
  set_has_is_transparent();
  is_transparent_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.is_transparent)
}

// required bool is_blocking = 9;
inline bool ActorData::has_is_blocking() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActorData::set_has_is_blocking() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActorData::clear_has_is_blocking() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActorData::clear_is_blocking() {
  is_blocking_ = false;
  clear_has_is_blocking();
}
inline bool ActorData::is_blocking() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.is_blocking)
  return is_blocking_;
}
inline void ActorData::set_is_blocking(bool value) {
  set_has_is_blocking();
  is_blocking_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.is_blocking)
}

// required string symbol = 10;
inline bool ActorData::has_symbol() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActorData::set_has_symbol() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActorData::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActorData::clear_symbol() {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_->clear();
  }
  clear_has_symbol();
}
inline const ::std::string& ActorData::symbol() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.symbol)
  return *symbol_;
}
inline void ActorData::set_symbol(const ::std::string& value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.ActorData.symbol)
}
inline void ActorData::set_symbol(const char* value) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.ActorData.symbol)
}
inline void ActorData::set_symbol(const char* value, size_t size) {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  symbol_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.ActorData.symbol)
}
inline ::std::string* ActorData::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    symbol_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.symbol)
  return symbol_;
}
inline ::std::string* ActorData::release_symbol() {
  clear_has_symbol();
  if (symbol_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = symbol_;
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActorData::set_allocated_symbol(::std::string* symbol) {
  if (symbol_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete symbol_;
  }
  if (symbol) {
    set_has_symbol();
    symbol_ = symbol;
  } else {
    clear_has_symbol();
    symbol_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.symbol)
}

// required int32 render_priority = 11;
inline bool ActorData::has_render_priority() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActorData::set_has_render_priority() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActorData::clear_has_render_priority() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActorData::clear_render_priority() {
  render_priority_ = 0;
  clear_has_render_priority();
}
inline ::google::protobuf::int32 ActorData::render_priority() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.render_priority)
  return render_priority_;
}
inline void ActorData::set_render_priority(::google::protobuf::int32 value) {
  set_has_render_priority();
  render_priority_ = value;
  // @@protoc_insertion_point(field_set:amarlon.ActorData.render_priority)
}

// required string color = 12;
inline bool ActorData::has_color() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ActorData::set_has_color() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ActorData::clear_has_color() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ActorData::clear_color() {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& ActorData::color() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.color)
  return *color_;
}
inline void ActorData::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set:amarlon.ActorData.color)
}
inline void ActorData::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(value);
  // @@protoc_insertion_point(field_set_char:amarlon.ActorData.color)
}
inline void ActorData::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:amarlon.ActorData.color)
}
inline ::std::string* ActorData::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    color_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.color)
  return color_;
}
inline ::std::string* ActorData::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ActorData::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.color)
}

// repeated .amarlon.StatusEffectData effects = 13;
inline int ActorData::effects_size() const {
  return effects_.size();
}
inline void ActorData::clear_effects() {
  effects_.Clear();
}
inline const ::amarlon::StatusEffectData& ActorData::effects(int index) const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.effects)
  return effects_.Get(index);
}
inline ::amarlon::StatusEffectData* ActorData::mutable_effects(int index) {
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.effects)
  return effects_.Mutable(index);
}
inline ::amarlon::StatusEffectData* ActorData::add_effects() {
  // @@protoc_insertion_point(field_add:amarlon.ActorData.effects)
  return effects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::amarlon::StatusEffectData >&
ActorData::effects() const {
  // @@protoc_insertion_point(field_list:amarlon.ActorData.effects)
  return effects_;
}
inline ::google::protobuf::RepeatedPtrField< ::amarlon::StatusEffectData >*
ActorData::mutable_effects() {
  // @@protoc_insertion_point(field_mutable_list:amarlon.ActorData.effects)
  return &effects_;
}

// optional .amarlon.AiData ai = 14;
inline bool ActorData::has_ai() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ActorData::set_has_ai() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ActorData::clear_has_ai() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ActorData::clear_ai() {
  if (ai_ != NULL) ai_->::amarlon::AiData::Clear();
  clear_has_ai();
}
inline const ::amarlon::AiData& ActorData::ai() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.ai)
  return ai_ != NULL ? *ai_ : *default_instance_->ai_;
}
inline ::amarlon::AiData* ActorData::mutable_ai() {
  set_has_ai();
  if (ai_ == NULL) ai_ = new ::amarlon::AiData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.ai)
  return ai_;
}
inline ::amarlon::AiData* ActorData::release_ai() {
  clear_has_ai();
  ::amarlon::AiData* temp = ai_;
  ai_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_ai(::amarlon::AiData* ai) {
  delete ai_;
  ai_ = ai;
  if (ai) {
    set_has_ai();
  } else {
    clear_has_ai();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.ai)
}

// optional .amarlon.CharacterData character = 15;
inline bool ActorData::has_character() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ActorData::set_has_character() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ActorData::clear_has_character() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ActorData::clear_character() {
  if (character_ != NULL) character_->::amarlon::CharacterData::Clear();
  clear_has_character();
}
inline const ::amarlon::CharacterData& ActorData::character() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.character)
  return character_ != NULL ? *character_ : *default_instance_->character_;
}
inline ::amarlon::CharacterData* ActorData::mutable_character() {
  set_has_character();
  if (character_ == NULL) character_ = new ::amarlon::CharacterData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.character)
  return character_;
}
inline ::amarlon::CharacterData* ActorData::release_character() {
  clear_has_character();
  ::amarlon::CharacterData* temp = character_;
  character_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_character(::amarlon::CharacterData* character) {
  delete character_;
  character_ = character;
  if (character) {
    set_has_character();
  } else {
    clear_has_character();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.character)
}

// optional .amarlon.DestroyableData destroyable = 16;
inline bool ActorData::has_destroyable() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ActorData::set_has_destroyable() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ActorData::clear_has_destroyable() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ActorData::clear_destroyable() {
  if (destroyable_ != NULL) destroyable_->::amarlon::DestroyableData::Clear();
  clear_has_destroyable();
}
inline const ::amarlon::DestroyableData& ActorData::destroyable() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.destroyable)
  return destroyable_ != NULL ? *destroyable_ : *default_instance_->destroyable_;
}
inline ::amarlon::DestroyableData* ActorData::mutable_destroyable() {
  set_has_destroyable();
  if (destroyable_ == NULL) destroyable_ = new ::amarlon::DestroyableData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.destroyable)
  return destroyable_;
}
inline ::amarlon::DestroyableData* ActorData::release_destroyable() {
  clear_has_destroyable();
  ::amarlon::DestroyableData* temp = destroyable_;
  destroyable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_destroyable(::amarlon::DestroyableData* destroyable) {
  delete destroyable_;
  destroyable_ = destroyable;
  if (destroyable) {
    set_has_destroyable();
  } else {
    clear_has_destroyable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.destroyable)
}

// optional .amarlon.InventoryData inventory = 17;
inline bool ActorData::has_inventory() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ActorData::set_has_inventory() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ActorData::clear_has_inventory() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ActorData::clear_inventory() {
  if (inventory_ != NULL) inventory_->::amarlon::InventoryData::Clear();
  clear_has_inventory();
}
inline const ::amarlon::InventoryData& ActorData::inventory() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.inventory)
  return inventory_ != NULL ? *inventory_ : *default_instance_->inventory_;
}
inline ::amarlon::InventoryData* ActorData::mutable_inventory() {
  set_has_inventory();
  if (inventory_ == NULL) inventory_ = new ::amarlon::InventoryData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.inventory)
  return inventory_;
}
inline ::amarlon::InventoryData* ActorData::release_inventory() {
  clear_has_inventory();
  ::amarlon::InventoryData* temp = inventory_;
  inventory_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_inventory(::amarlon::InventoryData* inventory) {
  delete inventory_;
  inventory_ = inventory;
  if (inventory) {
    set_has_inventory();
  } else {
    clear_has_inventory();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.inventory)
}

// optional .amarlon.OpenableData openable = 18;
inline bool ActorData::has_openable() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ActorData::set_has_openable() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ActorData::clear_has_openable() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ActorData::clear_openable() {
  if (openable_ != NULL) openable_->::amarlon::OpenableData::Clear();
  clear_has_openable();
}
inline const ::amarlon::OpenableData& ActorData::openable() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.openable)
  return openable_ != NULL ? *openable_ : *default_instance_->openable_;
}
inline ::amarlon::OpenableData* ActorData::mutable_openable() {
  set_has_openable();
  if (openable_ == NULL) openable_ = new ::amarlon::OpenableData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.openable)
  return openable_;
}
inline ::amarlon::OpenableData* ActorData::release_openable() {
  clear_has_openable();
  ::amarlon::OpenableData* temp = openable_;
  openable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_openable(::amarlon::OpenableData* openable) {
  delete openable_;
  openable_ = openable;
  if (openable) {
    set_has_openable();
  } else {
    clear_has_openable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.openable)
}

// optional .amarlon.PickableData pickable = 19;
inline bool ActorData::has_pickable() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ActorData::set_has_pickable() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ActorData::clear_has_pickable() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ActorData::clear_pickable() {
  if (pickable_ != NULL) pickable_->::amarlon::PickableData::Clear();
  clear_has_pickable();
}
inline const ::amarlon::PickableData& ActorData::pickable() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.pickable)
  return pickable_ != NULL ? *pickable_ : *default_instance_->pickable_;
}
inline ::amarlon::PickableData* ActorData::mutable_pickable() {
  set_has_pickable();
  if (pickable_ == NULL) pickable_ = new ::amarlon::PickableData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.pickable)
  return pickable_;
}
inline ::amarlon::PickableData* ActorData::release_pickable() {
  clear_has_pickable();
  ::amarlon::PickableData* temp = pickable_;
  pickable_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_pickable(::amarlon::PickableData* pickable) {
  delete pickable_;
  pickable_ = pickable;
  if (pickable) {
    set_has_pickable();
  } else {
    clear_has_pickable();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.pickable)
}

// optional .amarlon.TrapData trap = 20;
inline bool ActorData::has_trap() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ActorData::set_has_trap() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ActorData::clear_has_trap() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ActorData::clear_trap() {
  if (trap_ != NULL) trap_->::amarlon::TrapData::Clear();
  clear_has_trap();
}
inline const ::amarlon::TrapData& ActorData::trap() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.trap)
  return trap_ != NULL ? *trap_ : *default_instance_->trap_;
}
inline ::amarlon::TrapData* ActorData::mutable_trap() {
  set_has_trap();
  if (trap_ == NULL) trap_ = new ::amarlon::TrapData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.trap)
  return trap_;
}
inline ::amarlon::TrapData* ActorData::release_trap() {
  clear_has_trap();
  ::amarlon::TrapData* temp = trap_;
  trap_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_trap(::amarlon::TrapData* trap) {
  delete trap_;
  trap_ = trap;
  if (trap) {
    set_has_trap();
  } else {
    clear_has_trap();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.trap)
}

// optional .amarlon.WearerData wearer = 21;
inline bool ActorData::has_wearer() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ActorData::set_has_wearer() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ActorData::clear_has_wearer() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ActorData::clear_wearer() {
  if (wearer_ != NULL) wearer_->::amarlon::WearerData::Clear();
  clear_has_wearer();
}
inline const ::amarlon::WearerData& ActorData::wearer() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.wearer)
  return wearer_ != NULL ? *wearer_ : *default_instance_->wearer_;
}
inline ::amarlon::WearerData* ActorData::mutable_wearer() {
  set_has_wearer();
  if (wearer_ == NULL) wearer_ = new ::amarlon::WearerData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.wearer)
  return wearer_;
}
inline ::amarlon::WearerData* ActorData::release_wearer() {
  clear_has_wearer();
  ::amarlon::WearerData* temp = wearer_;
  wearer_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_wearer(::amarlon::WearerData* wearer) {
  delete wearer_;
  wearer_ = wearer;
  if (wearer) {
    set_has_wearer();
  } else {
    clear_has_wearer();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.wearer)
}

// optional .amarlon.TalkerData talker = 22;
inline bool ActorData::has_talker() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ActorData::set_has_talker() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ActorData::clear_has_talker() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ActorData::clear_talker() {
  if (talker_ != NULL) talker_->::amarlon::TalkerData::Clear();
  clear_has_talker();
}
inline const ::amarlon::TalkerData& ActorData::talker() const {
  // @@protoc_insertion_point(field_get:amarlon.ActorData.talker)
  return talker_ != NULL ? *talker_ : *default_instance_->talker_;
}
inline ::amarlon::TalkerData* ActorData::mutable_talker() {
  set_has_talker();
  if (talker_ == NULL) talker_ = new ::amarlon::TalkerData;
  // @@protoc_insertion_point(field_mutable:amarlon.ActorData.talker)
  return talker_;
}
inline ::amarlon::TalkerData* ActorData::release_talker() {
  clear_has_talker();
  ::amarlon::TalkerData* temp = talker_;
  talker_ = NULL;
  return temp;
}
inline void ActorData::set_allocated_talker(::amarlon::TalkerData* talker) {
  delete talker_;
  talker_ = talker;
  if (talker) {
    set_has_talker();
  } else {
    clear_has_talker();
  }
  // @@protoc_insertion_point(field_set_allocated:amarlon.ActorData.talker)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace amarlon

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_actor_2eproto__INCLUDED
